[{"title":"导数的应用","url":"/article/导数的应用","content":"导数的应用 - 切线和法线方程f(x0){f}(x_0)f(x0​) 在几何上表示曲线y=f(x)y=f(x)y=f(x)在(x0,f(x0))(x_0,f(x_0))(x0​,f(x0​))处的切线斜率切线方程：y−y0=f′(x0)(x−X0)y-y_0={f}'(x_0)(x-X_0)y−y0​=f′(x0​)(x−X0​)法线方程：y−y0=−1f′(x0)(x−x0)y-y_0=-\\frac{1}{{f}'(x_0)}(x-x_0)y−y0​=−f′(x0​)1​(x−x0​)求隐函数的导数（1）定义：显函数y=f(x)y=f(x)y=f(x)，隐函数F(x,y)F(x,y)F(x,y)（2）方法：方程两边同时对xxx求导，接触y′{y}'y′例：设x2y−e2x=sin⁡yx^2y-e^{2x}=\\sin yx2y−e2x=siny，求dydx\\frac{\\mathrm{d}y}{\\mathrm{d}x}dxdy​.解：方程两边同时对x求导得：2xy+x2⋅y′−2⋅e2x=y′⋅cos⁡y(x2−cos⁡y)⋅y′=2e2x−2xyy′=2e2x−2xyx2−cos⁡y方程两边同时对x求导得： \\\\\\\\     2xy+x^2·{y}'-2·e^{2x}={y}'·\\cos y \\\\\\\\     (x^2-\\cos y)·{y}'=2e^{2x}-2xy \\\\\\\\     {y}'=\\frac{2e^{2x}-2xy}{x^2-\\cos y}方程两边同时对x求导得：2xy+x2⋅y′−2⋅e2x=y′⋅cosy(x2−cosy)⋅y′=2e2x−2xyy′=x2−cosy2e2x−2xy​求幂指函数的导数方法一：先取对数再求导（对数求导法）方法二：化为以eee为底的指数函数后再求导（y=ux=exlnuy=u^x=e^{xlnu}y=ux=exlnu）例：求y=xsin⁡xy=x^{\\sin x}y=xsinx 函数的导数dydx\\frac{\\mathrm{d}y}{\\mathrm{d}x}dxdy​解：法一：方程两边同时取对数：lny=lnxsin⁡x=sin⁡xlnx方程两边同时对x求导：1y⋅y′=cos⁡x⋅lnx+sin⁡x⋅1x⇒y′=y(cos⁡xlnx+sin⁡xx)⇒y′=xsin⁡x(cos⁡xlnx+sin⁡xx)方程两边同时取对数：lny=lnx^{\\sin x}=\\sin xlnx \\\\\\\\          方程两边同时对x求导：\\frac{1}{y}·{y}'=\\cos x · lnx+\\sin x·\\frac{1}{x} \\\\\\\\          \\Rightarrow {y}'=y(\\cos x lnx+\\frac{\\sin x}{x}) \\\\\\\\          \\Rightarrow {y}'=x^{\\sin x}(\\cos x lnx+\\frac{\\sin x}{x})方程两边同时取对数：lny=lnxsinx=sinxlnx方程两边同时对x求导：y1​⋅y′=cosx⋅lnx+sinx⋅x1​⇒y′=y(cosxlnx+xsinx​)⇒y′=xsinx(cosxlnx+xsinx​)​\t\t法二：y=xsin⁡x=esin⁡xlnx​y′=esin⁡xlnx(sin⁡xlnx)′=xsin⁡x(cos⁡xlnx+sin⁡xx)y=x^{\\sin x}=e^{\\sin xlnx} \\\\\\\\​              {y}'=e^{\\sin xlnx}{(\\sin xlnx)}'=x^{\\sin x}(\\cos xlnx+\\frac{\\sin x}{x})y=xsinx=esinxlnx​y′=esinxlnx(sinxlnx)′=xsinx(cosxlnx+xsinx​)求由参数方程确定的函数的导数（1）参数方程：{x=φ(t)y=ψ(t)\\left\\{\\begin{matrix} x=\\varphi(t) \\\\\\\\ y=\\psi(t) \\end{matrix}\\right.⎩⎨⎧​x=φ(t)y=ψ(t)​（2）求导方法：dydx=dydtdxdt=φ′(t)ψ′(t)d2ydx2=ddx(dydx)=d(dydx)dtdxdt\\frac{\\mathrm{d}y}{\\mathrm{d}x}=\\frac{\\frac{\\mathrm{d}y}{\\mathrm{d}t}}{\\frac{\\mathrm{d}x}{\\mathrm{d}t}}=\\frac{{\\varphi}'(t)}{{\\psi}'(t)} \\\\\\\\             \\frac{\\mathrm{d^2}y}{\\mathrm{d}x^2}=\\frac{\\mathrm{d}}{\\mathrm{d}x}(\\frac{\\mathrm{d}y}{\\mathrm{d}x})=\\frac{\\frac{\\mathrm{d}(\\frac{\\mathrm{d}y}{\\mathrm{d}x})}{\\mathrm{d}t}}{\\frac{\\mathrm{d}x}{\\mathrm{d}t}}dxdy​=dtdx​dtdy​​=ψ′(t)φ′(t)​dx2d2y​=dxd​(dxdy​)=dtdx​dtd(dxdy​)​​求微分1、对于一元函数，可微⇔\\Leftrightarrow⇔可导2、函数y=f(x)y=f(x)y=f(x)的微分dy=f′(x)dx\\mathrm{d}y={f}'(x)\\mathrm{d}xdy=f′(x)dx3、求微分方法：先求导，再乘以dx\\mathrm{d}xdx微分在近似计算中的应用若f(x0)f(x_0)f(x0​)与f′(x0){f}'(x_0)f′(x0​)容易计算，用f(x)≈f(x0)+f′(x0)(x−x0)f(x)\\approx f(x_0)+{f}'(x_0)(x-x_0)f(x)≈f(x0​)+f′(x0​)(x−x0​) 近似计算f(x)f(x)f(x)"},{"title":"微分中值定理和导数的应用","url":"/article/微分中值定理和导数的应用","content":"微分中值定理和导数的应用 - 因为文章中包含大量数学公式，推荐使用电脑阅读本文章利用罗尔中值定理证明根的存在性例：设函数f(x)f(x)f(x)在闭区间[0,1][0,1][0,1]上连续，在开区间(0,1)(0,1)(0,1)内可导，且f(0)=0,f(1)=2f(0)=0,f(1)=2f(0)=0,f(1)=2，证明：在(0,1)(0,1)(0,1)内至少存在一点ξ\\xiξ，使得f′(ξ)=2ξ+1{f}'(\\xi )=2\\xi +1f′(ξ)=2ξ+1成立。证：（思路）构建辅助函数，得出原函数：{f′=2x+1f′−2x−1=0′f(x)−x2−x=0（思路）构建辅助函数，得出原函数：\\left\\{\\begin{matrix} {f}'=2x+1\\\\\\\\ {f}'-2x-1=0'\\\\\\\\ f(x)-x^2-x=0 \\end{matrix}\\right.（思路）构建辅助函数，得出原函数：⎩⎨⎧​f′=2x+1f′−2x−1=0′f(x)−x2−x=0​①设F(x)=f(x)−x2−x②∵f(x)在闭区间[0,1]上连续，开区间(0,1)内可导∴F(x)在[0,1]上连续，(01,)内可导,F(0)=f(0)=0,F(1)=f(1)−1−1=0③故，由罗尔定理可知,∃ξ∈(0,1),使得F′(ξ)=0,即f′(ξ)=2ξ+1①设F(x)=f(x)-x^2-x \\\\\\\\②\\because f(x)在闭区间[0,1]上连续，开区间(0,1)内可导 \\\\\\\\ \\therefore F(x)在[0,1]上连续，(01,)内可导, \\\\\\\\ F(0)=f(0)=0,F(1)=f(1)-1-1=0 \\\\\\\\ ③ 故，由罗尔定理可知, \\exists \\xi \\in (0,1),使得{F}'(\\xi )=0,即{f}'(\\xi )=2\\xi +1①设F(x)=f(x)−x2−x②∵f(x)在闭区间[0,1]上连续，开区间(0,1)内可导∴F(x)在[0,1]上连续，(01,)内可导,F(0)=f(0)=0,F(1)=f(1)−1−1=0③故，由罗尔定理可知,∃ξ∈(0,1),使得F′(ξ)=0,即f′(ξ)=2ξ+1利用拉格朗日中值定理证明不等式（1）构造辅助函数f(x)f(x)f(x)将中间部分写成差的形式，确定f(x)f(x)f(x)及区间[a,b][a,b][a,b].（2）验证拉格朗日中值定理的两个条件.（3）利用拉格朗日中值定理的结论得到等式.（4）利用ξ\\xiξ或f′(ξ){f}'(\\xi )f′(ξ)的取值范围得到不等式例：证明不等式m−nm0x>0x>0时，x>ln(1+x)x>ln(1+x)x>ln(1+x)证：①令f(x)=x−ln(1+x),x>0②f′(x)=1−11+x=x1+x>0⇒f(x)在区间内单调递增③∵x>0,f(x)>f(0)=0⇒x−ln(1+x)>0⇒x>ln(1+x)①令f(x)=x-ln(1+x),x>0 \\\\\\\\      ②{f}'(x)=1-\\frac{1}{1+x}=\\frac{x}{1+x}>0 \\Rightarrow f(x)在区间内单调递增 \\\\\\\\      ③\\because x>0,f(x)>f(0)=0 \\Rightarrow x-ln(1+x)>0 \\Rightarrow x>ln(1+x)①令f(x)=x−ln(1+x),x>0②f′(x)=1−1+x1​=1+xx​>0⇒f(x)在区间内单调递增③∵x>0,f(x)>f(0)=0⇒x−ln(1+x)>0⇒x>ln(1+x)极值的充分条件（1）第一充分条件：设f(x)f(x)f(x)在x0x_0x0​处连续，且在x0x_0x0​附近（x0x_0x0​除外）可导①若x0{f}'(x)>0f′(x)>0；x>x0x>x_0x>x0​时，f′(x)x0x>x_0x>x0​时，f′>0{f}'>0f′>0，则f(x)f(x)f(x)在x0x_0x0​处取得极小值（2）第二充分条件：设f(x)f(x)f(x)处具有二阶导数且f′(x0)=0,f′(x0)≠0{f}'(x_0)=0,{f}'(x_0)\\neq 0f′(x0​)=0,f′(x0​)=0①当f′′(x0)0{f}''(x_0)>0f′′(x0​)>0时，则f(x)f(x)f(x)在x0x_0x0​处取得极小值例：求函数f(x)=x+1x+1f(x)=x+\\frac{1}{x+1}f(x)=x+x+11​的极值解：①f′=1+1(x+1)2=(x+1)2−1(x+1)2=x(x+2)(x+1)2令f′(x)=0,得驻点x=0,−2③f′′(x)=2(x+1)(x+1)4=2(x+1)3f′′(0)=2>0⇒x=0是f(x)的极小值点f′′(−2)=−20 \\Rightarrow x=0是f(x)的极小值点 \\\\\\\\     {f}''(-2)=-20⇒x=0是f(x)的极小值点f′′(−2)=−20{f}''(x)>0f′′(x)>0，则曲线y=f(x)y=f(x)y=f(x)在(a,b)(a,b)(a,b)上是凹的。②如果在(a,b)(a,b)(a,b)内f′′(x)<0{f}''(x)<0f′′(x)<0，则曲线y=f(x)y=f(x)y=f(x)在(a,b)(a,b)(a,b)上是凹的。曲线的水平渐进线水平渐进线若lim⁡x→∞,+∞,−∞f(x)=A\\lim_{x \\to \\infty,+\\infty,-\\infty} f(x)=Alimx→∞,+∞,−∞​f(x)=A，则y=Ay=Ay=A为函数的一条水平渐进线垂直渐进线若lim⁡x→x0,x0+,x0−f(x)=∞\\lim_{x \\to x_0,x_0^+,x_0^-} f(x)=\\inftylimx→x0​,x0+​,x0−​​f(x)=∞，则x=x0x=x_0x=x0​为函数的一条垂直渐进线"},{"title":"微分中值定理与洛必达法则","url":"/article/微分中值定理与洛必达法则","content":"微分中值定理与洛必达法则 - 因为文章中包含大量数学公式，推荐使用电脑阅读本文章罗尔定理如果函数f(x)f(x)f(x)满足①在闭区间[a,b][a,b][a,b]上连续②在开区间(a,b)(a,b)(a,b)内可导③在区间端点处的函数值相等，即f(a)=f(b)f(a)=f(b)f(a)=f(b)，那么在(a,b)(a,b)(a,b)内至少有一点ξ(a<ξ<b),使得f′(ξ)=0\\xi (a< \\xi <b),使得{f}'(\\xi )=0ξ(a<ξ<b),使得f′(ξ)=0拉格朗日中值定理如果函数f(x)f(x)f(x)满足①在闭区间[a,b][a,b][a,b]上连续②在开区间(a,b)(a,b)(a,b)内可导那么在(a,b)(a,b)(a,b)内至少有一点ξ(a<ξ<b)，使等式f(b)−f(a)=f′(ξ)(b−a)成立\\xi (a< \\xi <b)，使等式f(b)-f(a)={f}'(\\xi )(b-a)成立ξ(a<ξ<b)，使等式f(b)−f(a)=f′(ξ)(b−a)成立柯西中值定理如果函数f(x)及F(x)f(x)及F(x)f(x)及F(x)满足①在闭区间[a,b][a,b][a,b]上连续②在开区间(a,b)(a,b)(a,b)内可导③对任一x∈(a,b),F′(x)≠0x\\in (a,b),{F}'(x)\\neq 0x∈(a,b),F′(x)=0，那么在(a,b)(a,b)(a,b)内至少有一点ξ(a<ξ<b)\\xi (a< \\xi <b)ξ(a<ξ<b)，使等式f(b)−f(a)F(b)−F(a)=f′(ξ)F′(ξ)\\frac{f(b)-f(a)}{F(b)-F(a)}=\\frac{{f}'(\\xi )}{{F}'(\\xi )}F(b)−F(a)f(b)−f(a)​=F′(ξ)f′(ξ)​洛必达法则设①当x⇒ax \\Rightarrow ax⇒a时，函数f(x)f(x)f(x)及F(x)F(x)F(x)都趋于零；②在点a的某去心邻域内，f′(x){f}'(x)f′(x)及F′(x){F}'(x)F′(x)都存在且F′(x)≠0{F}'(x)\\neq 0F′(x)=0③lim⁡x→af′(x)F′(x)\\lim_{x \\to a} \\frac{{f}'(x)}{{F}'(x)}limx→a​F′(x)f′(x)​存在（或为无穷大），那么lim⁡x→af(x)F(x)=lim⁡x→af′(x)F′(x),    \\lim_{x \\to a} \\frac{f(x)}{F(x)}=\\lim_{x \\to a} \\frac{{f}'(x)}{{F}'(x)},x→alim​F(x)f(x)​=x→alim​F′(x)f′(x)​,其中f(x)F(x)\\frac{f(x)}{F(x)}F(x)f(x)​也可以是∞∞\\frac{\\infty}{\\infty}∞∞​型未定式，f′(x),F′(x){f}'(x),{F}'(x)f′(x),F′(x)要存在且F′(x)≠0{F}'(x)\\neq 0F′(x)=0；相同的极限过程可以是x→a,x→a±,x→∞,x→±∞x\\rightarrow a,x \\rightarrow a^{\\pm },x \\rightarrow \\infty,x\\rightarrow \\pm \\infty x→a,x→a±,x→∞,x→±∞的任何一种，对于n→∞n \\rightarrow \\inftyn→∞，可用于子列极限定理，先化为x⇒+∞x \\Rightarrow +\\inftyx⇒+∞的极限对于其余五种非基本型未定式，应先变形或者取对数化为基本型，再用洛必达法则。"},{"title":"不定积分","url":"/article/single variable integral calculus","content":"不定积分 - 因为文章中包含大量数学公式，推荐使用电脑阅读本文章原函数与不定积分的概念原函数若对于某区间III上任意一点xxx，均有F′(x)=f(x)或dF(x)=f(x)dx{F}'(x)=f(x)或\\mathrm{d}F(x)=f(x)\\mathrm{d}xF′(x)=f(x)或dF(x)=f(x)dx，则称F(x)F(x)F(x)是f(x)f(x)f(x)在III上的一个原函数。原函数存在定理如果函数f(x)f(x)f(x)在区间III上连续，那么在区间III上存在可导函数F(x)F(x)F(x)，使对任意x∈Ix \\in Ix∈I都有F′(x)=f(x){F}'(x)=f(x)F′(x)=f(x)。不定积分f(x)f(x)f(x)在区间III上的原函数全体称为f(x)在III上的不定积分，即若F(x)F(x)F(x)是f(x)f(x)f(x)在III上的任一原函数，则∫f(x)dx=F(x)+C(C为任意常数)\\int f(x)\\mathrm{d}x=F(x)+C(C为任意常数)∫f(x)dx=F(x)+C(C为任意常数).由此定义可得下列关系：（1）∫f(x)dx′=f(x){\\int f(x)\\mathrm{d}x}'=f(x)∫f(x)dx′=f(x)    或   ∫f(x)dx=f(x)dx\\mathrm{\\int f(x)\\mathrm{d}x}=f(x)\\mathrm{d}x∫f(x)dx=f(x)dx（2）∫F′(x)=F(x)+C\\int {F}'(x)=F(x)+C∫F′(x)=F(x)+C   或   ∫dF(x)=F(x)+C\\int \\mathrm{d}F(x)=F(x)+C∫dF(x)=F(x)+C不定积分的性质设F(x)F(x)F(x)是f(x)f(x)f(x)的一个原函数，kkk为非零常数，则有（1）∫kf(x)dx=k∫f(x)dx\\int kf(x)\\mathrm{d}x=k\\int f(x)\\mathrm{d}x∫kf(x)dx=k∫f(x)dx;（2）∫[f(x)±g(x)]dx=∫f(x)dx±∫g(x)dx\\int [f(x) \\pm g(x)]\\mathrm{d}{x}=\\int f(x)\\mathrm{d}x \\pm \\int g(x)\\mathrm{d}x∫[f(x)±g(x)]dx=∫f(x)dx±∫g(x)dx基本积分公式基本积分公式∫xndx=1n+1xn+1,n≠−1(1)    \\tag{1}\\int x^n dx = \\frac{1}{n+1}x^{n+1},\\hspace{1ex}n\\neq -1∫xndx=n+11​xn+1,n=−1(1)∫1xdx=ln⁡∣x∣(2)    \\tag{2} \\int \\frac{1}{x}dx = \\ln |x|∫x1​dx=ln∣x∣(2)∫udv=uv−∫vdu(3)    \\tag{3} \\int u dv = uv - \\int v du∫udv=uv−∫vdu(3)∫1ax+bdx=1aln⁡∣ax+b∣(4)    \\tag{4} \\int \\frac{1}{ax+b}dx = \\frac{1}{a} \\ln |ax + b|∫ax+b1​dx=a1​ln∣ax+b∣(4)有理函数积分公式∫1(x+a)2dx=−1x+a(5)    \\tag{5} \\int \\frac{1}{(x+a)^2}dx = -\\frac{1}{x+a} ∫(x+a)21​dx=−x+a1​(5)∫(x+a)ndx=(x+a)n+1n+1,n≠−1(6)    \\tag{6} \\int (x+a)^n dx = \\frac{(x+a)^{n+1}}{n+1}, n\\ne -1∫(x+a)ndx=n+1(x+a)n+1​,n=−1(6)∫x(x+a)ndx=(x+a)n+1((n+1)x−a)(n+1)(n+2)(7)    \\tag{7} \\int x(x+a)^n dx = \\frac{(x+a)^{n+1} ( (n+1)x-a)}{(n+1)(n+2)}∫x(x+a)ndx=(n+1)(n+2)(x+a)n+1((n+1)x−a)​(7)∫11+x2dx=tan⁡−1x(8)    \\tag{8} \\int \\frac{1}{1+x^2}dx = \\tan^{-1}x∫1+x21​dx=tan−1x(8)∫1a2+x2dx=1atan⁡−1xa(9)    \\tag{9} \\int \\frac{1}{a^2+x^2}dx = \\frac{1}{a}\\tan^{-1}\\frac{x}{a}∫a2+x21​dx=a1​tan−1ax​(9)∫xa2+x2dx=12ln⁡∣a2+x2∣(10)    \\tag{10} \\int \\frac{x}{a^2+x^2}dx = \\frac{1}{2}\\ln|a^2+x^2|∫a2+x2x​dx=21​ln∣a2+x2∣(10)∫x2a2+x2dx=x−atan⁡−1xa(11)    \\tag{11} \\int \\frac{x^2}{a^2+x^2}dx = x-a\\tan^{-1}\\frac{x}{a}∫a2+x2x2​dx=x−atan−1ax​(11)∫x3a2+x2dx=12x2−12a2ln⁡∣a2+x2∣(12)    \\tag{12} \\int \\frac{x^3}{a^2+x^2}dx = \\frac{1}{2}x^2-\\frac{1}{2}a^2\\ln|a^2+x^2|∫a2+x2x3​dx=21​x2−21​a2ln∣a2+x2∣(12)∫1ax2+bx+cdx=24ac−b2tan⁡−12ax+b4ac−b2(13)    \\tag{13} \\int \\frac{1}{ax^2+bx+c}dx = \\frac{2}{\\sqrt{4ac-b^2}}\\tan^{-1}\\frac{2ax+b}{\\sqrt{4ac-b^2}}∫ax2+bx+c1​dx=4ac−b2​2​tan−14ac−b2​2ax+b​(13)∫1(x+a)(x+b)dx=1b−aln⁡a+xb+x, a≠b(14)    \\tag{14} \\int \\frac{1}{(x+a)(x+b)}dx = \\frac{1}{b-a}\\ln\\frac{a+x}{b+x}, \\text{ } a\\ne b∫(x+a)(x+b)1​dx=b−a1​lnb+xa+x​, a=b(14)∫x(x+a)2dx=aa+x+ln⁡∣a+x∣(15)    \\tag{15} \\int \\frac{x}{(x+a)^2}dx = \\frac{a}{a+x}+\\ln |a+x|∫(x+a)2x​dx=a+xa​+ln∣a+x∣(15)∫xax2+bx+cdx=12aln⁡∣ax2+bx+c∣−ba4ac−b2tan⁡−12ax+b4ac−b2(16)    \\tag{16} \\int \\frac{x}{ax^2+bx+c}dx = \\frac{1}{2a}\\ln|ax^2+bx+c| -\\frac{b}{a\\sqrt{4ac-b^2}}\\tan^{-1}\\frac{2ax+b}{\\sqrt{4ac-b^2}}∫ax2+bx+cx​dx=2a1​ln∣ax2+bx+c∣−a4ac−b2​b​tan−14ac−b2​2ax+b​(16)∫x−a dx=23(x−a)3/2(17)    \\tag{17} \\int \\sqrt{x-a}\\ dx = \\frac{2}{3}(x-a)^{3/2}∫x−a​ dx=32​(x−a)3/2(17)∫1x±a dx=2x±a(18)    \\tag{18} \\int \\frac{1}{\\sqrt{x\\pm a}}\\ dx = 2\\sqrt{x\\pm a}∫x±a​1​ dx=2x±a​(18)∫1a−x dx=−2a−x(19)    \\tag{19} \\int \\frac{1}{\\sqrt{a-x}}\\ dx = -2\\sqrt{a-x}∫a−x​1​ dx=−2a−x​(19)剩余待补充。求不定积分的基本方法第一类换元积分法（凑微分法）设F(x)F(x)F(x)是f(x)f(x)f(x)的一个原函数，则∫f[φ(x)][φ]′(x)dx=∫f[φ(x)]dφ(x)→令u=φ(x)∫f(u)du=F(u)+C=F[φ(x)]+C    \\int f[\\varphi(x)][\\varphi]'(x)\\mathrm{d}x = \\int f[\\varphi(x)]\\mathrm{d}\\varphi(x) \\xrightarrow[]{令u=\\varphi(x)}\\int f(u)\\mathrm{d}u \\\\\\\\ =F(u)+C = F[\\varphi(x)]+C∫f[φ(x)][φ]′(x)dx=∫f[φ(x)]dφ(x)令u=φ(x)​∫f(u)du=F(u)+C=F[φ(x)]+C第二类换元积分法设x=φ(t)x=\\varphi(t)x=φ(t)可导，且有反函数t=φ−1(x)t=\\varphi^{-1}(x)t=φ−1(x)，则有∫f(x)dx=∫f[φ(t)]φ′(t)dt∣t=φ−1(x)    \\int f(x)\\mathrm{d}x=\\int f[\\varphi(t)]{\\varphi}'(t)\\mathrm{d}t|_{t=\\varphi^{-1}(x)}∫f(x)dx=∫f[φ(t)]φ′(t)dt∣t=φ−1(x)​常用的换元法有：①∫R(x,a2+x2)dx,令x=atan⁡u或x=acot⁡u(R是有理数)\\int R(x,\\sqrt{a^2+x^2})\\mathrm{d}x,令x=a\\tan u 或 x=a\\cot u(R是有理数)∫R(x,a2+x2​)dx,令x=atanu或x=acotu(R是有理数)②∫R(x,a2−x2)dx,令x=asin⁡u或x=acos⁡u\\int R(x,\\sqrt{a^2-x^2})\\mathrm{d}x,令x=a\\sin u 或 x=a\\cos u∫R(x,a2−x2​)dx,令x=asinu或x=acosu③∫R(x,x2−a2)dx,令x=asec⁡u或x=acsc⁡u\\int R(x,\\sqrt{x^2-a^2})\\mathrm{d}x,令x=a\\sec u 或 x=a\\csc u∫R(x,x2−a2​)dx,令x=asecu或x=acscu④∫R(x,ax+bn)dx，令un=ax+b\\int R(x,\\sqrt[n]{ax+b})\\mathrm{d}x，令u^n=ax+b∫R(x,nax+b​)dx，令un=ax+b⑤∫R(xm,xn)dx,令x=uk,k是正整数m与n的最小公倍数\\int R(\\sqrt[m]{x},\\sqrt[n]{x})\\mathrm{d}x,令x=u^k,k是正整数m与n的最小公倍数∫R(mx​,nx​)dx,令x=uk,k是正整数m与n的最小公倍数⑥∫R(x,1axn+b)dx,令x=1t\\int R(x,\\frac{1}{ax^n+b})\\mathrm{d}x,令x=\\frac{1}{t}∫R(x,axn+b1​)dx,令x=t1​⑦∫R(x,ex)dx,令ex=t\\int R(x,e^x)\\mathrm{d}x,令e^x=t∫R(x,ex)dx,令ex=t分部积分法设u=u(x),v=v(x)u=u(x),v=v(x)u=u(x),v=v(x)均可微，则有分部积分公式∫udv=uv−∫vdu    \\int u\\mathrm{d}v=uv-\\int v\\mathrm{d}u∫udv=uv−∫vdu常见的类型：①∫P(x)ebxdx,令u=P(x),其中P(x)是多项式\\int P(x)e^{bx}\\mathrm{d}x,令u=P(x),其中P(x)是多项式∫P(x)ebxdx,令u=P(x),其中P(x)是多项式②∫P(x)sin⁡(ax+b)dx,令u=P(x)，也适用于cos⁡(ax+b)\\int P(x)\\sin (ax+b)\\mathrm{d}x,令u=P(x)，也适用于\\cos (ax+b)∫P(x)sin(ax+b)dx,令u=P(x)，也适用于cos(ax+b)③∫P(x)ln(ax+b)dx,令u=ln(ax+b)\\int P(x)ln(ax+b)\\mathrm{d}x,令u=ln(ax+b)∫P(x)ln(ax+b)dx,令u=ln(ax+b)④∫P(x)arcsin⁡(ax+b)dx,令u=arcsin⁡(ax+b)，也适用于arccos⁡(ax+b)或arctan⁡(ax+b)等\\int P(x)\\arcsin (ax+b)\\mathrm{d}x,令u=\\arcsin (ax+b)，也适用于\\arccos (ax+b)或\\arctan (ax+b)等∫P(x)arcsin(ax+b)dx,令u=arcsin(ax+b)，也适用于arccos(ax+b)或arctan(ax+b)等⑤∫eaxsin⁡(ax+b)dx,令u=sin⁡(ax+b)或u=eax,也适用于cos⁡(ax+b)\\int e^ax\\sin (ax+b)\\mathrm{d}x,令u=\\sin (ax+b)或u=e^{ax},也适用于\\cos (ax+b)∫eaxsin(ax+b)dx,令u=sin(ax+b)或u=eax,也适用于cos(ax+b)几种特殊类型函数的不定积分①有理函数的不定积分。a.∫Ax−adx=Aln∣x−a∣+C\\int \\frac{A}{x-a}\\mathrm{d}x=Aln|x-a|+C∫x−aA​dx=Aln∣x−a∣+Cb.∫A(x−a)ndx=A(1−n)(x−a)n−1+C(n>1)\\int \\frac{A}{(x-a)^n}\\mathrm{d}x=\\frac{A}{(1-n)(x-a)^{n-1}}+C(n>1)∫(x−a)nA​dx=(1−n)(x−a)n−1A​+C(n>1)②三角函数有理式的不定积分a.万能代换令t=tan⁡x2,sin⁡x=2t1+t2,cos⁡x=1−t21+t2,dx=21+t2dt,则令t=\\tan \\frac{x}{2},\\sin x = \\frac{2t}{1+t^2},\\cos x = \\frac{1-t^2}{1+t^2},\\mathrm{d}x=\\frac{2}{1+t^2}\\mathrm{d}t,则令t=tan2x​,sinx=1+t22t​,cosx=1+t21−t2​,dx=1+t22​dt,则∫R(sin⁡x,cos⁡x)dx=∫R(2t1+t2,1−t21+t2)⋅21+t2dt    \\int R(\\sin x,\\cos x)\\mathrm{d}x=\\int R(\\frac{2t}{1+t^2},\\frac{1-t^2}{1+t^2})·\\frac{2}{1+t^2}\\mathrm{d}t∫R(sinx,cosx)dx=∫R(1+t22t​,1+t21−t2​)⋅1+t22​dt"},{"title":"二阶常系数齐次线性微分方程","url":"/article/二阶常系数齐次线性微分方程","content":"二阶常系数齐次线性微分方程 - 因为文章中包含大量数学公式，推荐使用电脑阅读本文章标准形式y′+py′′+qy=0    {y}' +p{y}''  +qy=0y′+py′′+qy=0通解：①写出相应的特征方程 r2+pr+q=0r^2+pr+q=0r2+pr+q=0②求出特征根r1,r2r_1,r_2r1​,r2​③写出通解：1)不同实根：r1≠r2,y=C1er1x+C2er2xr_1 \\neq r_2, y=C_1e^{r_1x}+C_2e^{r_2x}r1​=r2​,y=C1​er1​x+C2​er2​x2)重根：r1=r2=r,y=C1erx+C2xerxr_1=r_2=r,y=C_1e^{rx}+C_2xe^{rx}r1​=r2​=r,y=C1​erx+C2​xerx2)共轭复根：r1,2=α±βi,y=eαx(C1cos⁡βx+C2sin⁡βx)r_{1,2}=\\alpha \\pm \\beta i, y=e^{\\alpha x}(C_1\\cos \\beta x + C_2 \\sin \\beta x)r1,2​=α±βi,y=eαx(C1​cosβx+C2​sinβx)例1：求微分方程y′′+2y′+y=0{y}''+2{y}'+y=0y′′+2y′+y=0的通解解：由题意得：特征方程：r2+2r+1=0⇒r1=r2=−1∴y=C1e−x+C2xe−x特征方程：r^2+2r+1=0 \\\\\\\\    \\Rightarrow r_1=r_2=-1 \\\\\\\\    \\therefore y=C_1e^{-x}+C_2xe^{-x}特征方程：r2+2r+1=0⇒r1​=r2​=−1∴y=C1​e−x+C2​xe−x例2：求微分方程y′′−4y=0{y}''-4y=0y′′−4y=0得通解解：由题意得：特征方程：r2−4=0⇒r1=2，r2=−2∴y=C1e2x+C−2e−2x特征方程：r^2-4=0 \\\\\\\\     \\Rightarrow r_1=2，r_2=-2 \\\\\\\\     \\therefore y=C_1e^{2x}+C-2e^{-2x}特征方程：r2−4=0⇒r1​=2，r2​=−2∴y=C1​e2x+C−2e−2x例3： 求微分方程2d2ydx2+4dydx+3y=02\\frac{\\mathrm{d}^2 y}{\\mathrm{d} x^2}+4\\frac{\\mathrm{d} y}{\\mathrm{d} x}+3y=02dx2d2y​+4dxdy​+3y=0的通解解：由题意得：特征方程：2r2+4r+3=0⇒r=−1±22i∴y=e−x(C1cos⁡22x+C2sin⁡22x)特征方程：2r^2+4r+3=0 \\\\\\\\     \\Rightarrow r=-1 \\pm \\frac{\\sqrt{2}}{2}i \\\\\\\\     \\therefore y=e^{-x}(C_1\\cos \\frac{\\sqrt{2}}{2}x+C_2\\sin \\frac{\\sqrt{2}}{2}x)特征方程：2r2+4r+3=0⇒r=−1±22​​i∴y=e−x(C1​cos22​​x+C2​sin22​​x)已知通解，反求微分方程①找出特征根②写出特征方程③写出微分方程例：写出通解为y=C1e−x+C2e3x(C1,C2为任意常数)y=C_1e^{-x}+C_2e^{3x}(C_1,C_2为任意常数)y=C1​e−x+C2​e3x(C1​,C2​为任意常数)的二阶线性常系数齐次微分方程解：由题意得：特征根：r1=−1,r2=3特征方程：(r+1)(r−3)=0⇒r2−2r−3=0微分方程：y′′−2y′−3y=0特征根：r_1=-1,r_2=3 \\\\\\\\           特征方程：(r+1)(r-3)=0  \\\\\\\\            \\Rightarrow r^2-2r-3=0 \\\\\\\\           微分方程：{y}''-2{y}'-3y=0特征根：r1​=−1,r2​=3特征方程：(r+1)(r−3)=0⇒r2−2r−3=0微分方程：y′′−2y′−3y=0"},{"title":"可降阶的高阶微分方程","url":"/article/可降阶的高阶微分方程","content":"可降阶的高阶微分方程 - 因为文章中包含大量数学公式，推荐使用电脑阅读本文章y(n)=f(x)y^{(n)}=f(x)y(n)=f(x)型解法：作n次不定积分例：求微分方程y′′′=24x{y}'''=24xy′′′=24x通解解：对原方程连续积分可得：y′′=∫24xdx=12x2+C1y′=∫(12x2+C1)dx=4x3+C1x+C2y=∫(4x3+C1x+C2)dx=x4+C1x22+C2x+C3{y}''=\\int 24x\\mathrm{d}x=12x^2+C_1 \\\\\\\\{y}'=\\int (12x^2+C_1)\\mathrm{d}x=4x^3+C_1x+C_2 \\\\\\\\y=\\int (4x^3+C_1x+C_2)\\mathrm{d}x=x^4+C_1\\frac{x^2}{2}+C_2x+C3y′′=∫24xdx=12x2+C1​y′=∫(12x2+C1​)dx=4x3+C1​x+C2​y=∫(4x3+C1​x+C2​)dx=x4+C1​2x2​+C2​x+C3y′′=f(x,y′){y}''=f(x,{y}')y′′=f(x,y′)型解法：令y′=P{y}'=Py′=P，两边对x求导，y′′=P{y}''=Py′′=P，然后代入原方程转化为一阶微分方程求解例：求微分方程xy′′+y′=4xx{y}''+{y}'=4xxy′′+y′=4x的通解解：令y′=P,y′′=P′代入原方程得：xP′+P=4x⇒P′+1xP=4可得：P=e−∫1xdx(∫4e∫1xdx+C−1)=e−lnx(∫4elnxdx+C1)=1x(∫4xdx+C1)=1x(2x2+C1)=2x+C11x⇒y′=2x+C1x⇒y=∫(2x+C1x)dx⇒y=x2+C1ln∣x∣+C−2令{y}'=P,{y}''={P}' \\\\\\\\     代入原方程得：x{P}'+P=4x \\\\\\\\      \\Rightarrow {P}'+\\frac{1}{x}P=4 \\\\\\\\     可得：P=e^{-\\int \\frac{1}{x}\\mathrm{d}x}(\\int 4e^{\\int \\frac{1}{x}}\\mathrm{d}x+C-1) \\\\\\\\     =e^{-lnx}(\\int 4e^{lnx}\\mathrm{d}x+C_1) \\\\\\\\     =\\frac{1}{x}(\\int 4x\\mathrm{d}x+C_1) \\\\\\\\     =\\frac{1}{x}(2x^2+C_1) \\\\\\\\     =2x+C_1\\frac{1}{x} \\\\\\\\     \\Rightarrow {y}'=2x+\\frac{C_1}{x} \\\\\\\\     \\Rightarrow y = \\int (2x+\\frac{C_1}{x})\\mathrm{d}x \\\\\\\\     \\Rightarrow y=x^2+C_1ln|x|+C-2令y′=P,y′′=P′代入原方程得：xP′+P=4x⇒P′+x1​P=4可得：P=e−∫x1​dx(∫4e∫x1​dx+C−1)=e−lnx(∫4elnxdx+C1​)=x1​(∫4xdx+C1​)=x1​(2x2+C1​)=2x+C1​x1​⇒y′=2x+xC1​​⇒y=∫(2x+xC1​​)dx⇒y=x2+C1​ln∣x∣+C−2y′′=f(y,y′){y}''=f(y,{y}')y′′=f(y,y′)型解法：令y′=P{y}'=Py′=P，两边对x求导，y′′=dPdx=dPdy⋅dydx=PdPdy{y}''=\\frac{\\mathrm{d}P}{\\mathrm{d}x}=\\frac{\\mathrm{d}P}{\\mathrm{d}y}·\\frac{\\mathrm{d}y}{\\mathrm{d}x}=P\\frac{\\mathrm{d}P}{\\mathrm{d}y}y′′=dxdP​=dydP​⋅dxdy​=PdydP​，然后代入原方程，转化为一阶微分方程求解例：求微分方程yy′′−(y′)2=0y{y}''-({y}')^2=0yy′′−(y′)2=0的通解解：令y′=P,y′′=P⋅dPdy代入原方程得：y⋅P⋅dPdy−P2=0⇒y⋅dPdy=P⇒dPP=dyy⇒∫dPP=∫dyy⇒ln∣P∣=ln∣y∣+ln∣C1∣⇒P=C1y⇒y′=C1y⇒dydx=C1y⇒dyy=C1dx⇒∫dyy=∫C1dx⇒ln∣y∣=C1x+ln∣C2∣⇒y=C2eC1x令{y}'=P,{y}''=P·\\frac{\\mathrm{d}P}{\\mathrm{d}y} 代入原方程得：\\\\\\\\     y·P·\\frac{\\mathrm{d}P}{\\mathrm{d}y}-P^2=0 \\\\\\\\     \\Rightarrow y·\\frac{\\mathrm{d}P}{\\mathrm{d}y}=P \\\\\\\\     \\Rightarrow \\frac{\\mathrm{d}P}{P}=\\frac{\\mathrm{d}y}{y} \\\\\\\\     \\Rightarrow \\int \\frac{\\mathrm{d}P}{P}=\\int \\frac{\\mathrm{d}y}{y} \\\\\\\\     \\Rightarrow ln|P|=ln|y|+ln|C_1| \\\\\\\\     \\Rightarrow P=C_1y \\Rightarrow {y}'=C_1y \\\\\\\\     \\Rightarrow \\frac{\\mathrm{d}y}{\\mathrm{d}x}=C_1y \\\\\\\\     \\Rightarrow \\frac{\\mathrm{d}y}{y}=C_1\\mathrm{d}x \\\\\\\\     \\Rightarrow \\int \\frac{\\mathrm{d}y}{y}=\\int C_1\\mathrm{d}x \\\\\\\\     \\Rightarrow ln|y|=C_1x+ln|C_2| \\\\\\\\     \\Rightarrow y=C_2e^{C_1x}令y′=P,y′′=P⋅dydP​代入原方程得：y⋅P⋅dydP​−P2=0⇒y⋅dydP​=P⇒PdP​=ydy​⇒∫PdP​=∫ydy​⇒ln∣P∣=ln∣y∣+ln∣C1​∣⇒P=C1​y⇒y′=C1​y⇒dxdy​=C1​y⇒ydy​=C1​dx⇒∫ydy​=∫C1​dx⇒ln∣y∣=C1​x+ln∣C2​∣⇒y=C2​eC1​x"},{"title":"一阶线性微分方程","url":"/article/一阶线性微分方程","content":"一阶线性微分方程 - 因为文章中包含大量数学公式，推荐使用电脑阅读本文章标准形式$${y}'+P(x)y=Q(x)$$解法①化为标准形式②套公式：$$y = e^{-\\int P(x)\\mathrm{d}x}(\\int Q(x)e^{\\int P(x)\\mathrm{d}x}\\mathrm{d}x+C)$$注：在此公式中，解不定积分时，不加绝对值，也不加任意常数C例：解方程xy′−y=x3x{y}'-y=x^3xy′−y=x3解：原方程可化为：y′−1xy=x2由公式得：y=e−∫1xdx(∫x2e−∫1xdxdx+C)=elnx(∫x2e−lnxdx+C)=x(∫x2⋅1xdx+C)=x(x22+C)=x32+Cx即y=x32+Cx{y}'-\\frac{1}{x}y=x^2 \\\\\\\\                由公式得：y=e^{-\\int \\frac{1}{x}\\mathrm{d}x}(\\int x^2e^{-\\int \\frac{1}{x}\\mathrm{d}x}\\mathrm{d}x+C) \\\\\\\\                =e^{lnx}(\\int x^2e^{-lnx}\\mathrm{d}x+C) \\\\\\\\                =x(\\int x^2·\\frac{1}{x}\\mathrm{d}x+C) \\\\\\\\                =x(\\frac{x^2}{2}+C) \\\\\\\\                =\\frac{x^3}{2}+Cx \\\\\\\\                即 y=\\frac{x^3}{2}+Cxy′−x1​y=x2由公式得：y=e−∫x1​dx(∫x2e−∫x1​dxdx+C)=elnx(∫x2e−lnxdx+C)=x(∫x2⋅x1​dx+C)=x(2x2​+C)=2x3​+Cx即y=2x3​+Cx"},{"title":"齐次方程","url":"/article/齐次方程","content":"齐次方程 - 因为文章中包含大量数学公式，推荐使用电脑阅读本文章解法①化为标准形式：y′=f(yx){y}'=f(\\frac{y}{x})y′=f(xy​)②代入u=yxu=\\frac{y}{x}u=xy​，代入方程小区y③化为x与u的可分离变量的微分方程，求解例1：求xy′−xsin⁡yx−y=0x{y}'-x\\sin\\frac{y}{x}-y=0xy′−xsinxy​−y=0的通解。解：原方程可化为：y′−sin⁡yx=0⇒y′=sin⁡yx+yx令yx=u,y=xu,y′=u+xu代入原方程得：u+xu′=sin⁡u+u⇒xdudx=sin⁡u⇒dusin⁡u=dxx⇒∫1sin⁡udu=∫1xdx⇒ln∣csc⁡u−cot⁡u∣=ln∣x∣+ln∣C∣⇒csc⁡u−cot⁡u=Cx⇒csc⁡yx−cot⁡yx=Cx即原方程的通解是csc⁡yx−cot⁡yx=Cx{y}'-\\sin\\frac{y}{x}=0 \\Rightarrow {y}'=\\sin\\frac{y}{x}+\\frac{y}{x} \\\\\\\\                 令\\frac{y}{x}=u, y=xu, {y}'=u+xu \\\\\\\\                 代入原方程得：u+x{u}'=\\sin u+u \\\\\\\\                 \\Rightarrow x\\frac{\\mathrm{d} u}{\\mathrm{d} x} = \\sin u \\\\\\\\                 \\Rightarrow \\frac{\\mathrm{d} u}{\\sin u} = \\frac{\\mathrm{d} x}{x} \\\\\\\\                 \\Rightarrow \\int \\frac{1}{\\sin u}\\mathrm{d} u = \\int \\frac{1}{x}\\mathrm{d} x \\\\\\\\                 \\Rightarrow ln|\\csc u - \\cot u| = ln|x| + ln|C| \\\\\\\\                 \\Rightarrow \\csc u - \\cot u = Cx \\\\\\\\                 \\Rightarrow \\csc\\frac{y}{x}-\\cot\\frac{y}{x}=Cx \\\\\\\\                 即原方程的通解是\\csc\\frac{y}{x}-\\cot\\frac{y}{x}=Cxy′−sinxy​=0⇒y′=sinxy​+xy​令xy​=u,y=xu,y′=u+xu代入原方程得：u+xu′=sinu+u⇒xdxdu​=sinu⇒sinudu​=xdx​⇒∫sinu1​du=∫x1​dx⇒ln∣cscu−cotu∣=ln∣x∣+ln∣C∣⇒cscu−cotu=Cx⇒cscxy​−cotxy​=Cx即原方程的通解是cscxy​−cotxy​=Cx"},{"title":"常微分方程","url":"/article/常微分方程","content":"常微分方程 - 因为文章中包含大量数学公式，推荐使用电脑阅读本文章常微分方程的解若y=φ(x)y=\\varphi (x)y=φ(x)代入方程成为恒等式，则称y=φ(x)y=\\varphi (x)y=φ(x)为方程的一个解。通解含有相互独立（不能合并，y=C1x+C2x2与y=C1x+C2xy=C_1x+C_2x^2与y=C_1x+C_2xy=C1​x+C2​x2与y=C1​x+C2​x）的任意常数，且任意常数的个数与方程的阶数相同的微分方程的解。特解不含任意常数的解。例：已知微分方程y′+ay=ex{y}'+ay=e^xy′+ay=ex的一个特解为y=xexy=xe^xy=xex,则a=__.解：y′=ex+x⋅ex=(1+x)ex代入微分方程得:(1+x)ex+a⋅xex=ex⇒(1+x+ax)ex=ex⇒a=−1{y}'=e^x+x·e^x=(1+x)e^x \\\\\\\\代入微分方程得: (1+x)e^x+a·xe^x=e^x \\\\\\\\\\Rightarrow (1+x+ax)e^x=e^x \\\\\\\\ \\Rightarrow a=-1y′=ex+x⋅ex=(1+x)ex代入微分方程得:(1+x)ex+a⋅xex=ex⇒(1+x+ax)ex=ex⇒a=−1可分离变量的微分方程标准形式$$f(x) \\mathrm{d} y=g(x) \\mathrm{d} x$$解法①分离变量，化为标准形式②两边同时积分例1：求方程sec⁡2x+tan⁡ydx+sec⁡2ytan⁡xdy=0\\sec^2x+\\tan y \\mathrm{d} x + \\sec^2 y \\tan x \\mathrm{d} y = 0sec2x+tanydx+sec2ytanxdy=0的通解解：原方程可化为：sec⁡2x+tan⁡ydx=−sec⁡2ytan⁡xdy⇒sec⁡2xtan⁡xdx=−sec⁡2ytan⁡ydx⇒∫sec⁡2xtan⁡xdx=−∫sec⁡2ytan⁡ydx⇒∫1tan⁡xd(tan⁡x)=−∫1tan⁡yd(tan⁡y)⇒ln∣tan⁡x∣=−ln∣(tan⁡y)∣+ln∣C∣⇒ln∣tan⁡x∣+ln∣(tan⁡y)∣=ln∣C∣⇒ln∣tan⁡xtan⁡y=ln∣C∣⇒tan⁡xtan⁡y=C即原微分方程的通解是:tan⁡xtan⁡y=C\\sec^2x+\\tan y \\mathrm{d} x = - \\sec^2 y \\tan x \\mathrm{d} y  \\\\\\\\\\Rightarrow \\frac{\\sec^2 x}{\\tan x} \\mathrm{d} x = - \\frac{\\sec^2 y}{\\tan y} \\mathrm{d} x \\\\\\\\\\Rightarrow \\int \\frac{\\sec^2 x}{\\tan x} \\mathrm{d} x = - \\int \\frac{\\sec^2 y}{\\tan y} \\mathrm{d} x \\\\\\\\\\Rightarrow \\int \\frac{1}{\\tan x} \\mathrm{d} (\\tan x) = - \\int \\frac{1}{\\tan y} \\mathrm{d} (\\tan y) \\\\\\\\\\Rightarrow ln|\\tan x| = - ln|(\\tan y)| + ln|C| \\\\\\\\\\Rightarrow ln|\\tan x| + ln|(\\tan y)|= ln|C| \\\\\\\\\\Rightarrow ln|\\tan x \\tan y= ln|C|  \\\\\\\\\\Rightarrow \\tan x \\tan y= C \\\\\\\\即原微分方程的通解是:\\tan x \\tan y= Csec2x+tanydx=−sec2ytanxdy⇒tanxsec2x​dx=−tanysec2y​dx⇒∫tanxsec2x​dx=−∫tanysec2y​dx⇒∫tanx1​d(tanx)=−∫tany1​d(tany)⇒ln∣tanx∣=−ln∣(tany)∣+ln∣C∣⇒ln∣tanx∣+ln∣(tany)∣=ln∣C∣⇒ln∣tanxtany=ln∣C∣⇒tanxtany=C即原微分方程的通解是:tanxtany=C例2：求微分方程dy−2xy2dx=0\\mathrm{d} y - 2xy^2 \\mathrm{d} x = 0dy−2xy2dx=0满足条件y(1)=−1y(1)=-1y(1)=−1的特解解：原方程可化为：dy=2xy2⇒1y2dy=2xdx⇒∫1y2dy=∫2xdx⇒−1y=x2+C⇒y=−1x2+Cy(1)=−11+C=−1⇒C=0即原方程满足y(1)=−1的特解是:y=−1x2\\mathrm{d} y = 2xy^2 \\\\\\\\                 \\Rightarrow \\frac{1}{y^2} \\mathrm{d} y = 2x \\mathrm{d} x \\\\\\\\                 \\Rightarrow \\int \\frac{1}{y^2} \\mathrm{d} y = \\int 2x \\mathrm{d} x \\\\\\\\                 \\Rightarrow -\\frac{1}{y} = x^2+C \\\\\\\\                 \\Rightarrow y = - \\frac{1}{x^2+C} \\\\\\\\                 y(1)=-\\frac{1}{1+C}=-1 \\\\\\\\                 \\Rightarrow C=0 \\\\\\\\                 即原方程满足y(1)=-1的特解是: y=-\\frac{1}{x^2}dy=2xy2⇒y21​dy=2xdx⇒∫y21​dy=∫2xdx⇒−y1​=x2+C⇒y=−x2+C1​y(1)=−1+C1​=−1⇒C=0即原方程满足y(1)=−1的特解是:y=−x21​"},{"title":"空间曲面及其方程","url":"/article/空间曲面面及其方程","content":"空间曲面及其方程 - 球面球心在点M0(x0,y0,z0)M_0(x_0,y_0,z_0)M0​(x0​,y0​,z0​)，半径为R的球面方程为：$$(x-x_0)^2+(y-y_0)^2+(z-z_0)^2=R^2$$球面的一般方程：Ax2+Ay2+Az2+Dx+Ey+Fz+G=0Ax^2+Ay^2+Az^2+Dx+Ey+Fz+G=0Ax2+Ay2+Az2+Dx+Ey+Fz+G=0**平面方程的特点：**①三元二次方程；②缺交叉项③平方项系数相同柱面定义：直线（母线）沿着定曲线（准线）平行移动所产生的曲面柱面方程的特点： 二元方程旋转曲面特点： 至少有2个变量的二次项系数相等常见的二次曲面椭球面：x2a2+y2b2+z2c2=1\\frac{x^2}{a^2}+\\frac{y^2}{b^2}+\\frac{z^2}{c^2}=1a2x2​+b2y2​+c2z2​=1单叶双曲面：x2a2+y2b2−z2c2=1\\frac{x^2}{a^2}+\\frac{y^2}{b^2}-\\frac{z^2}{c^2}=1a2x2​+b2y2​−c2z2​=1双叶双曲面：x2a2−y2b2−z2c2=1\\frac{x^2}{a^2}-\\frac{y^2}{b^2}-\\frac{z^2}{c^2}=1a2x2​−b2y2​−c2z2​=1锥面：x2a2+y2b2−z2c2=0\\frac{x^2}{a^2}+\\frac{y^2}{b^2}-\\frac{z^2}{c^2}=0a2x2​+b2y2​−c2z2​=0椭圆抛物面：x22p+y22q=z(p,q同号)\\frac{x^2}{2p}+\\frac{y^2}{2q}=z(p,q同号)2px2​+2qy2​=z(p,q同号)双曲抛物线：x22p−y22q=z(p,q同号)\\frac{x^2}{2p}-\\frac{y^2}{2q}=z(p,q同号)2px2​−2qy2​=z(p,q同号)"},{"title":"空间直线方程","url":"/article/空间直线方程","content":"空间直线方程 - 空间直线的方程直线的一般方程L={A1x+B1y+C1z+D1=0A2x+B2y+C2z+D2=0    L = \\left\\{\\begin{matrix} A_1x+B_1y+C_1z+D_1=0 \\\\ A_2x+B_2y+C_2z+D_2=0 \\end{matrix}\\right.L={A1​x+B1​y+C1​z+D1​=0A2​x+B2​y+C2​z+D2​=0​直线的点向式方程已知有一点M0(x0,y0,z0)M_0(x_0,y_0,z_0)M0​(x0​,y0​,z0​)，方向向量s⃗=(m,n,p)\\vec{s}=(m,n,p)s=(m,n,p)，则有：x−x0m=y−y0n=z−z0p    \\frac{x-x_0}{m}=\\frac{y-y_0}{n}=\\frac{z-z_0}{p}mx−x0​​=ny−y0​​=pz−z0​​直线的参数方程x−x0m=y−y0n=z−z0p=t⇒{x=x0+mty=y0+ntz=z0+pt    \\frac{x-x_0}{m}=\\frac{y-y_0}{n}=\\frac{z-z_0}{p}=t \\Rightarrow \\left\\{\\begin{matrix} x= x_0+mt \\\\ y=y_0+nt \\\\ z=z_0+pt \\end{matrix}\\right.mx−x0​​=ny−y0​​=pz−z0​​=t⇒⎩⎨⎧​x=x0​+mty=y0​+ntz=z0​+pt​直线的两点式方程x−x−1x2−x1=y−y1y2−y1=z−z1z2−z1    \\frac{x-x-1}{x_2-x_1}=\\frac{y-y_1}{y_2-y_1}=\\frac{z-z_1}{z_2-z_1}x2​−x1​x−x−1​=y2​−y1​y−y1​​=z2​−z1​z−z1​​空间中两直线的位置关系L1:x−x1m1=y−y1n1=z−z1p1L_1: \\frac{x-x_1}{m_1}=\\frac{y-y_1}{n_1}=\\frac{z-z_1}{p_1}L1​:m1​x−x1​​=n1​y−y1​​=p1​z−z1​​  s1⃗=(m1,n1,p1)\\vec{s_1}=(m_1,n_1,p_1)s1​​=(m1​,n1​,p1​)L2:x−x2m2=y−y2n2=z−z2p2L_2: \\frac{x-x_2}{m_2}=\\frac{y-y_2}{n_2}=\\frac{z-z_2}{p_2}L2​:m2​x−x2​​=n2​y−y2​​=p2​z−z2​​  s2⃗=(m2,n2,p2)\\vec{s_2}=(m_2,n_2,p_2)s2​​=(m2​,n2​,p2​)①m1m2=n1n2=p1p2⇔s1⃗//s2⃗L1//L2\\frac{m_1}{m_2}=\\frac{n_1}{n_2}=\\frac{p_1}{p_2} \\Leftrightarrow \\vec{s_1} // \\vec{s_2} L_1 // L_2 m2​m1​​=n2​n1​​=p2​p1​​⇔s1​​//s2​​L1​//L2​②m1m2+n1n2+p1p2=0⇔s1⃗⊥s2⃗⇔L1⊥L2m_1m_2 + n_1n_2 + p_1p_2 = 0 \\Leftrightarrow \\vec{s_1} \\perp \\vec{s_2} \\Leftrightarrow L_1 \\perp L_2m1​m2​+n1​n2​+p1​p2​=0⇔s1​​⊥s2​​⇔L1​⊥L2​③cos⁡θ=cos⁡(s1⃗,s2⃗)=∣s1⃗⋅s2⃗∣∣s1⃗∣∣s2⃗∣,θ∈[0,π2]\\cos\\theta = \\cos(\\vec{s_1},\\vec{s_2}) = \\frac{|\\vec{s_1}·\\vec{s_2}|}{|\\vec{s_1}||\\vec{s_2}|},\\theta \\in [0,\\frac{\\pi}{2}]cosθ=cos(s1​​,s2​​)=∣s1​​∣∣s2​​∣∣s1​​⋅s2​​∣​,θ∈[0,2π​]直线与平面的位置关系L:x−x0m=y−y0n=z−z0pL: \\frac{x-x_0}{m}=\\frac{y-y_0}{n}=\\frac{z-z_0}{p}L:mx−x0​​=ny−y0​​=pz−z0​​   s⃗=(m,n,p)\\vec{s}=(m,n,p)s=(m,n,p)π:Ax+Bx+Cz+D=0\\pi: Ax+Bx+Cz+D=0π:Ax+Bx+Cz+D=0    n⃗=A,B,C\\vec{n}={A,B,C}n=A,B,C①Am=Bn=Cp⇔n⃗//s⃗⇔L⊥π\\frac{A}{m}=\\frac{B}{n}=\\frac{C}{p} \\Leftrightarrow \\vec{n} // \\vec{s} \\Leftrightarrow L \\perp \\pimA​=nB​=pC​⇔n//s⇔L⊥π②Am+Bn+Cp=0⇔n⃗⊥s⃗⇔πAm+Bn+Cp=0 \\Leftrightarrow \\vec{n} \\perp \\vec{s} \\Leftrightarrow \\piAm+Bn+Cp=0⇔n⊥s⇔π​     将直线上已知点的坐标(x0,y0,z0)(x_0,y_0,z_0)(x0​,y0​,z0​)代入平面的方程中，若恒成立，则直线在平面上，否则，平行。③sin⁡ϕ=cos⁡(s⃗,n⃗)=∣s⃗⋅n⃗∣∣s⃗∣⋅∣n⃗∣,ϕ∈[0,π2]\\sin\\phi = \\cos(\\vec{s},\\vec{n}) = \\frac{|\\vec{s}·\\vec{n}|}{|\\vec{s}|·|\\vec{n}|},\\phi \\in [0,\\frac{\\pi}{2}]sinϕ=cos(s,n)=∣s∣⋅∣n∣∣s⋅n∣​,ϕ∈[0,2π​]"},{"title":"空间中两平面的位置关系","url":"/article/可空间中两平面的位置关系","content":"空间中两平面的位置关系 - 两平面的位置关系平面π1\\pi_{1}π1​： A1x+B1y+C1z+D1=0n1⃗=(A1,B1,C1)A_{1}x + B_{1}y + C_{1}z + D_{1} = 0  \\\\\\\\ \\vec{n_{1}} = (A_{1}, B_{1}, C_{1}) A1​x+B1​y+C1​z+D1​=0n1​​=(A1​,B1​,C1​)平面π2\\pi_{2}π2​: A2x+B2y+C2z+D2=0n2⃗=(A2,B2,C2)A_{2}x + B_{2}y + C_{2}z + D_{2} = 0  \\\\\\\\ \\vec{n_{2}} = (A_{2}, B_{2}, C_{2})A2​x+B2​y+C2​z+D2​=0n2​​=(A2​,B2​,C2​)① A1A2=B1B2=C1C2⇔n1⃗//n2⃗⇔π1//π2\\frac{A_{1}}{A_{2}} = \\frac{B_{1}}{B_{2}} = \\frac{C_{1}}{C_{2}} \\Leftrightarrow \\vec{n_{1}} // \\vec{n_{2}} \\Leftrightarrow \\pi_{1} // \\pi_{2} A2​A1​​=B2​B1​​=C2​C1​​⇔n1​​//n2​​⇔π1​//π2​​    若A1A2=B1B2=C1C2=D1D2,π1与π2\\frac{A_{1}}{A_{2}} = \\frac{B_{1}}{B_{2}} = \\frac{C_{1}}{C_{2}} = \\frac{D_{1}}{D_{2}} ,\\pi_{1}与\\pi_{2}A2​A1​​=B2​B1​​=C2​C1​​=D2​D1​​,π1​与π2​重合​    若A1A2=B1B2=C1C2≠D1D2,π1与π2\\frac{A_{1}}{A_{2}} = \\frac{B_{1}}{B_{2}} = \\frac{C_{1}}{C_{2}}  \\neq \\frac{D_{1}}{D_{2}} ,\\pi_{1}与\\pi_{2}A2​A1​​=B2​B1​​=C2​C1​​=D2​D1​​,π1​与π2​平行不重合②A1A2+B1B2+C1C2=0⇔n1⃗⊥n2⃗⇔π1⊥π2A_{1}A_{2} + B_{1}B_{2} + C_{1}C_{2} = 0 \\Leftrightarrow \\vec{n_{1}} \\perp \\vec{n_{2}} \\Leftrightarrow \\pi_{1} \\perp \\pi_{2}A1​A2​+B1​B2​+C1​C2​=0⇔n1​​⊥n2​​⇔π1​⊥π2​③cos⁡θ=cos⁡(n1⃗,n2⃗)=∣n1⃗⋅n2⃗∣∣n1⃗∣∣n2⃗∣,θ∈[0,π2]\\cos\\theta = \\cos(\\vec{n_{1}}, \\vec{n_{2}}) = \\frac{|\\vec{n_{1}}·\\vec{n_{2}}|}{|\\vec{n_{1}}||\\vec{n_{2}}|},\\theta \\in [0, \\frac{\\pi}{2}]cosθ=cos(n1​​,n2​​)=∣n1​​∣∣n2​​∣∣n1​​⋅n2​​∣​,θ∈[0,2π​]点到平面的位置点M0(x0,y0,z0)M_{0}(x_{0},y_{0},z_{0})M0​(x0​,y0​,z0​)到平面π：Ax+By+Cz+D=0\\pi：Ax + By + Cz + D = 0π：Ax+By+Cz+D=0的距离d为:d=Ax0+By0+Cz0+DA2+B2+C2    d = \\frac{Ax_{0}+By_{0}+Cz_{0}+D}{\\sqrt{A^2+B^2+C^2}}d=A2+B2+C2​Ax0​+By0​+Cz0​+D​两平行平面的距离π1:Ax+By+Cz+D1=0π2:Ax+By+Cz+D2=0\\pi_{1}: Ax + By + Cz + D_{1} = 0 \\\\\\\\  \\pi_{2}: Ax + By + Cz + D_{2} = 0π1​:Ax+By+Cz+D1​=0π2​:Ax+By+Cz+D2​=0d=∣D1−D2∣A2+B2+C2    d = \\frac{|D_{1}-D_{2}|}{\\sqrt{A^2+B^2+C^2}}d=A2+B2+C2​∣D1​−D2​∣​"},{"title":"向量的线性运算","url":"/article/Vector-Algebra-and-Analytic-Geometry","content":"向量的线性运算 - 加法**定义1：**设a⃗=(a1,a2)\\vec{a} = (a_1, a_2)a=(a1​,a2​)，b⃗=(b1,b2)\\vec{b} = (b_1, b_2)b=(b1​,b2​)是二维空间向量R2R^2R2中的两个向量，定义它们的加法为$$\\vec{a} + \\vec{b} = (a_1 + b_1, a_2 + b_2)$$定义1：设a⃗=(a1,a2,a3)\\vec{a} = (a_1, a_2, a_3)a=(a1​,a2​,a3​)，b⃗=(b1,b2,b3)\\vec{b} = (b_1, b_2, b_3)b=(b1​,b2​,b3​)是三维向量空间R3R^3R3中的两个向量，定义它们的加法为：$$\\vec{a} + \\vec{b} = (a_1 + b_1, a_2 + b_2, a_3 + b_3)$$​\t一般的，设a⃗=(a1,a2,⋅⋅⋅,an),b⃗=(b1,b2,⋅⋅⋅,bn)\\vec{a} = (a_1,a_2,···,a_n),\\vec{b} = (b_1,b_2,···,b_n)a=(a1​,a2​,⋅⋅⋅,an​),b=(b1​,b2​,⋅⋅⋅,bn​)是n维向量空间RnR^nRn中的两个向量，定义它们的加法为：$$\\vec{a} + \\vec{b} = (a_1+b_1,a_2+b_2,···,a_n+b_n)$$运算规律：​\t数乘定义3：设a⃗=(a1,a2)\\vec{a} = (a_1, a_2)a=(a1​,a2​)，b⃗=(b1,b2)\\vec{b} = (b_1, b_2)b=(b1​,b2​)是二维空间向量R2R^2R2中的两个向量，λ\\lambdaλ是实数，定义λ\\lambdaλ与a⃗\\vec{a}a的数乘为：$$\\lambda\\vec{a} = (\\lambda a_1, \\lambda a_2)$$设a⃗\\vec{a}a是非零向量，λ\\lambdaλ是非零实数，记b⃗=λa⃗\\vec{b} = \\lambda \\vec{a}b=λa，则有$$|\\vec{b}| = \\sqrt{(\\lambda a_1)^2 + (\\lambda a_2)^2 } = |\\lambda| \\sqrt{(a_1)^2 + ( a_2)^2} = |\\lambda||\\vec{a}|$$定义4：设a⃗=(a1,a2,a3)\\vec{a} = (a_1, a_2, a_3)a=(a1​,a2​,a3​)，b⃗=(b1,b2,b3)\\vec{b} = (b_1, b_2, b_3)b=(b1​,b2​,b3​)是三维空间向量R3R^3R3中的两个向量，λ\\lambdaλ是实数，定义λ\\lambdaλ与a⃗\\vec{a}a的数乘为：$$\\lambda\\vec{a} = (\\lambda a_1, \\lambda a_2, \\lambda a_3)$$一般的，对于n维向量与实数的数乘以此类推。减法利用向量的加法与数乘运算，得出向量的减法$$\\vec{a} - \\vec{b} = \\vec{a} + (-1) \\vec{b}$$单位向量表示设eae_aea​表示非零向量a⃗\\vec{a}a同向的单位向量，则有$$\\vec{a} = |\\vec{a}|e_a 或 e_a = \\frac{\\vec{a}}{|\\vec{a}|}$$称eae_aea​为a⃗\\vec{a}a的单位方向向量对于三维向量a⃗\\vec{a}a，有$$e_a = (\\cos \\alpha, \\cos \\beta, \\cos \\gamma)     \\vec{a} = |\\vec{a}(\\cos \\alpha, \\cos \\beta, \\cos \\gamma)| $$向量平行等价说法：（1）a⃗//b⃗\\vec{a} // \\vec{b}a//b（2）存在实数λ\\lambdaλ，使得b⃗=λa⃗\\vec{b} = \\lambda \\vec{a}b=λa（3）a⃗与b⃗\\vec{a}与\\vec{b}a与b对应分量成比例$$\\vec{a} = (a_1,a_2,a_3)，\\vec{b} = (b_1, b_2, b_3) \\Rightarrow \\frac{a_1}{b_1}=\\frac{a_2}{b_2}=\\frac{a_3}{b_3}$$（4）存在不全为零的常数k1,k2k_1,k_2k1​,k2​，使得k1a⃗+k2b⃗=0k_1\\vec{a} + k_2\\vec{b} = 0k1​a+k2​b=0例：设a⃗=(2,1),b⃗=(−3,1)\\vec{a} = (2,1),\\vec{b} = (-3,1)a=(2,1),b=(−3,1)，求c⃗=a⃗+2b⃗\\vec{c} = \\vec{a}+2\\vec{b}c=a+2b的单位向量解： \\vec{c} = \\vec{a} + 2\\vec{b} \\\\\\\\           = (2, 1) + 2 (-3, 1) \\\\\\\\           =(-4, 3) \\\\\\\\      |\\vec{c}| = \\sqrt{(-4)^2 + 3^2} = 5 \\\\\\\\      e_\\vec{c} = \\frac{1}{5}(-4,3) = (-\\frac{4}{5},\\frac{3}{5})向量的基表示在二维空间中，记i⃗=(1,0)，j⃗=(0,1)\\vec{i} = (1, 0)，\\vec{j} = (0, 1)i=(1,0)，j​=(0,1)，则i⃗,j⃗\\vec{i}, \\vec{j}i,j​分别是与x轴、y轴同向的单位向量方向向量，称之为二维空间中的基向量。**在三维空间中，**记i⃗=(1,0,0),j⃗=(0,1,0),k⃗=(0,0,1)\\vec{i}=(1,0,0),\\vec{j}=(0,1,0),\\vec{k}=(0,0,1)i=(1,0,0),j​=(0,1,0),k=(0,0,1)，则i⃗,j⃗,k⃗\\vec{i},\\vec{j},\\vec{k}i,j​,k是与x轴、y轴、z轴同向的单位方向向量，称之为三维向量空间的基向量。向量a⃗=(a1,a2,a3)\\vec{a} = (a_1,a_2,a_3)a=(a1​,a2​,a3​)可表示为$$\\vec{a} = a_1\\vec{i} + a_2\\vec{j} + a_3\\vec{k}$$上式称为三维向量a⃗\\vec{a}a的基表示或基向量分解式。例：设A(x1,y1，z1)和B(x2,y2,z2)A(x_1, y_1，z_1 )和B(x_2,y_2,z_2)A(x1​,y1​，z1​)和B(x2​,y2​,z2​)为已知两点，而在AB直线上的点M分为有向线段AB→\\overrightarrow{AB}AB为两个有向线段AM→和MB→\\overrightarrow{AM}和\\overrightarrow{MB}AM和MB，并使AM→=λMB→(λ≠−1为常数)\\overrightarrow{AM} = \\lambda \\overrightarrow{MB} (\\lambda \\neq -1 为常数)AM=λMB(λ=−1为常数)，求分点M的坐标。解： 设M(x,y,z)，由于AM→=(x−x1,y−y1,z−z1)MB→=(x2−x,y2−x,z2−z)由AM→=λMB→得(x−x1,y−y1,z−z1)=λ(x2−x,y2−x,z2−z)⇒x−x1=λ(x2−x),y−y1=λ(y2−y),z−z1=λ(z2−z)⇒x=x1+λx21+λ,y=y1+λy21+λ,z=z1+λz21+λ则得点M的坐标为（x1+λx21+λ，y1+λy2,1+λ,z1+λz21+λ）设M(x, y, z)，由于\\\\\\\\\\overrightarrow{AM} = (x-x_1,y-y_1,z-z_1) \\\\\\\\ \\overrightarrow{MB} = (x_2- x, y_2-x, z_2-z) \\\\\\\\由\\overrightarrow{AM} = \\lambda \\overrightarrow{MB}得 \\\\\\\\(x-x_1,y-y_1,z-z_1) = \\lambda (x_2- x, y_2-x, z_2-z) \\\\\\\\\\Rightarrow x-x_1 = \\lambda (x_2-x),y-y_1 = \\lambda (y_2-y),z-z_1 = \\lambda (z_2-z) \\\\\\\\\\Rightarrow x = \\frac{x_1+\\lambda x_2}{1+\\lambda},y = \\frac{y_1+\\lambda y_2}{1+\\lambda},z = \\frac{z_1+\\lambda z_2}{1+\\lambda} \\\\\\\\则得点M的坐标为（\\frac{x_1+\\lambda x_2}{1+\\lambda}，\\frac{y_1+\\lambda y_2} ,{1+\\lambda},\\frac{z_1+\\lambda z_2}{1+\\lambda}）设M(x,y,z)，由于AM=(x−x1​,y−y1​,z−z1​)MB=(x2​−x,y2​−x,z2​−z)由AM=λMB得(x−x1​,y−y1​,z−z1​)=λ(x2​−x,y2​−x,z2​−z)⇒x−x1​=λ(x2​−x),y−y1​=λ(y2​−y),z−z1​=λ(z2​−z)⇒x=1+λx1​+λx2​​,y=1+λy1​+λy2​​,z=1+λz1​+λz2​​则得点M的坐标为（1+λx1​+λx2​​，,y1​+λy2​​1+λ,1+λz1​+λz2​​）A(x1,y1，z1)和B(x2,y2,z2)A(x_1, y_1，z_1 )和B(x_2,y_2,z_2)A(x1​,y1​，z1​)和B(x2​,y2​,z2​)的中点坐标为(x1+x2+x32,y1+y2+y32,z1+z2+z32)(\\frac{x_1+x_2+x_3}{2},\\frac{y_1+y_2+y_3}{2},\\frac{z_1+z_2+z_3}{2})(2x1​+x2​+x3​​,2y1​+y2​+y3​​,2z1​+z2​+z3​​)"},{"title":"向量的基本概念","url":"/article/Vector-Algebra-and-Analytic-Geometry","content":"向量的基本概念 - 向量的基本概念向量：既有大小，又有方向的量。数量：只有大小，没有方向的量。向量表示法：用一条带箭头的线段（即有向线段）表示如：AB→\\overrightarrow{AB}AB A为起点，B为终点还可以用粗体字母或带箭头的字母表示向量例如：v，a，F  或 v⃗\\vec{v}v，a⃗\\vec{a}a， F⃗\\vec{F}F对于自由向量，如果向量a⃗\\vec{a}a与b⃗\\vec{b}b大小相等且方向相同，则称a⃗\\vec{a}a与b⃗\\vec{b}b相等，记作 a⃗\\vec{a}a = b⃗\\vec{b}b向量的模：向量的大小。表示方法：∣AB→∣|\\overrightarrow{AB}|∣AB∣或a或∣a⃗∣|\\vec{a}|∣a∣单位向量：模等于1的向量。零向量：模为零的向量。记作0或0⃗\\vec{0}0. 零向量的起点与终点重合，他的方向可以看作是任意的。向量平行：两个非零向量如果它们的方向相同或者相反，就称这两个向量平行。如果向量a⃗\\vec{a}a和b⃗\\vec{b}b平行，记作a⃗//b⃗\\vec{a}//\\vec{b}a//b。零向量与任何向量平行。负向量：与a⃗\\vec{a}a的模相同，但方向相反的向量，记作−a⃗-\\vec{a}−a向量共线：即两向量平行。向量共面：向量经平移可移到同一平面上。空间向量的坐标表示前置：平面上点P(x, y) ⇌\\rightleftharpoons ⇌ 向量OP→\\overrightarrow{OP}OP（称为径向量）对平面上的两点A(x1,y1)A(x_1, y_1)A(x1​,y1​)，B(x2,y2)B(x_2, y_2)B(x2​,y2​)，有向线段AB→\\overrightarrow{AB}AB的坐标表示向量AB→\\overrightarrow{AB}AB与x轴和y轴的正向夹角α\\alpha α和β\\betaβ称为方向角空间向量的坐标表示∣AB→∣=(x2−x−1,y2−y1,z2−z1)      |\\overrightarrow{AB}| = (x_2 - x-1, y_2 - y1, z_2 - z_1)∣AB∣=(x2​−x−1,y2​−y1,z2​−z1​)其中x2−x−1,y2−y1,z2−z1x_2 - x-1, y_2 - y1, z_2 - z_1x2​−x−1,y2​−y1,z2​−z1​分别称为∣AB→∣|\\overrightarrow{AB}|∣AB∣的x, y, z轴方向上的分量。方向角：0≤α,β,γ≤π0 \\leq  \\alpha , \\beta, \\gamma  \\leq  \\pi0≤α,β,γ≤π方向余弦：cos⁡α,cos⁡β,cos⁡γ\\cos\\alpha , \\cos\\beta, \\cos\\gammacosα,cosβ,cosγ空间中的向量也由他的分量唯一确定。因此一个空间的向量通常表示为a⃗=(a1,a2,a3)\\vec{a} = (a_1, a_2, a_3)a=(a1​,a2​,a3​)并且称它为一个三位向量，且有：∣a⃗∣=a12+a22+a32|\\vec{a}| = \\sqrt{a_1^2 + a_2^2 + a_3^2}∣a∣=a12​+a22​+a32​​                   cos⁡α=a1a12+a22+a32\\cos\\alpha = \\frac{a_1}{\\sqrt{a_1^2 + a_2^2 + a_3^2}}cosα=a12​+a22​+a32​​a1​​cos⁡β=a2a12+a22+a32\\cos\\beta = \\frac{a_2}{\\sqrt{a_1^2 + a_2^2 + a_3^2}}cosβ=a12​+a22​+a32​​a2​​       cos⁡γ=a3a12+a22+a32\\cos\\gamma = \\frac{a_3}{\\sqrt{a_1^2 + a_2^2 + a_3^2}}cosγ=a12​+a22​+a32​​a3​​例：求从原点到点M(1, 1, 1)的向量OM→\\overrightarrow{OM}OM的模，方向余弦与方向角。解：OM→=(1−0,1−0,1−0,)=(1,1,1)\\overrightarrow{OM} = (1-0, 1-0, 1-0,) = (1, 1, 1)OM=(1−0,1−0,1−0,)=(1,1,1)​     模：  ∣OM→∣=12+12+12=3|\\overrightarrow{OM}| = \\sqrt{1^2+1^2+1^2} = \\sqrt{3}∣OM∣=12+12+12​=3​​     方向余弦：cos⁡α=13\\cos\\alpha = \\frac{1}{\\sqrt{3}}cosα=3​1​        cos⁡β=13\\cos\\beta = \\frac{1}{\\sqrt{3}}cosβ=3​1​          cos⁡γ=13\\cos\\gamma = \\frac{1}{\\sqrt{3}}cosγ=3​1​​    方向角：α=β=γ=arccos⁡13\\alpha = \\beta = \\gamma = \\arccos\\frac{1}{\\sqrt{3}}α=β=γ=arccos3​1​"},{"title":"空间中两点的距离","url":"/article/空间中两点的距离","content":"空间中两点的距离 - 前置：数轴上两点的距离$$|M_1M_2| = |x_2 - x_1|$$前置：平面上两点的距离$$|M_1M_2| = \\sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}$$空间中两点的距离假设空间中两点，M1M_1M1​为(x1,y1,z1)(x_1, y_1, z_1)(x1​,y1​,z1​),M2M_2M2​为(x2,y2,z2)(x_2, y_2, z_2)(x2​,y2​,z2​)，则距离公示为：$$|M_1M_2| = \\sqrt{(x_2-x_1)^2 + (y_2-y_1)^2 + (z_2 - z_1)^2}$$特别的，点M(x, y, z)到原点O(0, 0, 0)的距离为：$$|OM| = \\sqrt{x^2 + y^2 + z^2}$$例题1 在z轴上求两点A(3，1，-4)和B(5，3，2)等距离的点。解：设z轴上点为M(0, 0, z)，由题意|MA| = |MB|，即​         (3−0)2+(1−0)2+(−4−z)2=(5−0)2+(3−0)2+(2−z)2\\sqrt{(3-0)^2 + (1-0)^2 + (-4 - z)^2} = \\sqrt{(5-0)^2 + (3-0)^2 + (2-z)^2}(3−0)2+(1−0)2+(−4−z)2​=(5−0)2+(3−0)2+(2−z)2​解得，z = 1，所求点位为M(0,0,1)。"},{"title":"空间直角坐标系","url":"/article/空间直角坐标系","content":"空间直角坐标系 - 前言：空间直角坐标系过空间中一定点O，作三条互相垂直的数轴构成的坐标系称为空间直角坐标系。坐标原点：O点坐标轴：x轴，y轴，z轴右手坐标系：用右手握住z轴，使大拇指的方向指向Z轴的正向，其他手指的方向就是从x轴的正向到y轴的正向坐标面：xOy平面，yOz平面，xOz平面，卦限：八个卦限空间中点的坐标点M  有序三元数组(x, y, z)有序三元数组(x, y, z)称为点M的坐标x - 横坐标；y - 纵坐标；z - 竖坐标点M也记为：M(x, y, z)所有的有序三元数组的集合记作：R3={(x,y,z)∣xϵR,yϵR,zϵR}R^3 = \\{(x,y,z)|x\\epsilon R,y\\epsilon R,z\\epsilon R\\}R3={(x,y,z)∣xϵR,yϵR,zϵR}坐标轴：x轴 ↔{y=0z=0\\leftrightarrow   \\begin{cases} y= 0 \\\\\\\\  z= 0 \\end{cases}↔⎩⎨⎧​y=0z=0​     y轴 ↔{z=0x=0\\leftrightarrow  \\begin{cases} z= 0 \\\\\\\\ x= 0 \\end{cases}↔⎩⎨⎧​z=0x=0​      z轴 ↔{x=0y=0\\leftrightarrow  \\begin{cases} x= 0 \\\\\\\\ y= 0 \\end{cases}↔⎩⎨⎧​x=0y=0​坐标面：xOy面：↔\\leftrightarrow↔  z = 0                              yOz面：↔\\leftrightarrow↔  x = 0           zOx面：↔\\leftrightarrow↔  y = 0"},{"title":"SpringBoot Jpa @OneByOne双向查询报栈溢出原因","url":"/article/SpringBoot Jpa @OneByOne双向查询报栈溢出原因","content":"SpringBoot Jpa @OneByOne双向查询报栈溢出原因 - 示例：@Data@Entitypublic class User {    @Id    @GeneratedValue(strategy = GenerationType.IDENTITY)    private Integer uid;    /**用户名*/    private String username;    /**用户密码*/    private String password;    /**注册时间*/    private Timestamp regTime;    /**性别*/    private Boolean sex;    @OneToOne(cascade = CascadeType.ALL)    @JoinColumn(name = \"weixin\")    private WXToken wxToken;}@Data@Entitypublic class WXToken {    /**微信号*/    @Id    private String weixin;    /**微信token授权*/    private String token;    /**授权开始时间*/    private Timestamp startTime;    /**授权过期时间*/    private Timestamp expireTime;    @OneToOne(mappedBy = \"wxToken\", cascade = CascadeType.ALL)    private User user;}报错：java.lang.StackOverflowError\tat java.lang.AbstractStringBuilder.append(AbstractStringBuilder.java:675)\tat java.lang.StringBuilder.append(StringBuilder.java:208)\tat java.sql.Timestamp.toString(Timestamp.java:302)\tat java.lang.String.valueOf(String.java:2994)\tat java.lang.StringBuilder.append(StringBuilder.java:131)\tat com.nosky.hnsoftshow.domain.WXToken.toString(WXToken.java:8)\tat java.lang.String.valueOf(String.java:2994)\tat java.lang.StringBuilder.append(StringBuilder.java:131)\tat com.nosky.hnsoftshow.domain.User.toString(User.java:10)\tat java.lang.String.valueOf(String.java:2994)\tat java.lang.StringBuilder.append(StringBuilder.java:131)\tat com.nosky.hnsoftshow.domain.WXToken.toString(WXToken.java:8)\tat java.lang.String.valueOf(String.java:2994)...原因：​实体类的toString()方法被无限递归解决：​去掉任意一个实体的toString()，或者两个都可去掉V2EX有关这个类似问题的讨论与更加合理的解决方案"},{"title":"Maven与eclipse","url":"/article/Maven与eclipse","content":"Maven与eclipse - Maven配置与eclipse配置Maven仓库下载与安装1、前往 https://maven.apache.org/download.cgi 下载最新版的Maven程序：2、将文件解压到F:\\Program Files\\Apache\\apache-maven-3.5.3（此处是我的安装路径）目录下:​3、新建环境变量MAVEN_HOME，赋值F:\\Program Files\\Apache\\apache-maven-3.5.3​4、编辑环境变量Path，追加%MAVEN_HOME%\\bin\\;5、至此，maven已经完成了安装，我们可以通过DOS命令检查一下我们是否安装成功​​\tmvn -v配置Maven本地仓库1、在F:\\Program Files\\Apache\\目录下新建maven-repository文件夹，该目录用作maven的本地库。2、打开F:\\Program Files\\Apache\\apache-maven-3.5.3\\conf\\settings.xml文件，查找下面这行代码：​​\t/path/to/local/repolocalRepository节点默认是被注释掉的，需要把它移到注释之外，然后将localRepository节点的值改为我们在3.1中创建的目录F:\\Program Files\\Apache\\maven-repository3、localRepository节点用于配置本地仓库，本地仓库其实起到了一个缓存的作用，它的默认地址是 C:\\Users\\用户名.m2。当我们从maven中获取jar包的时候，maven首先会在本地仓库中查找，如果本地仓库有则返回；如果没有则从远程仓库中获取包，并在本地库中保存。此外，我们在maven项目中运行mvn install，项目将会自动打包并安装到本地仓库中。4、运行一下DOS命令mvn help:system如果前面的配置成功，那么F:\\Program Files\\Apache\\maven-repository会出现一些文件。配置Eclipse的Maven环境1、Eclipse Oxygen，打开Window->Preferences->Maven->Installations，右侧点击Add。2、设置maven的安装目录，然后Finish3、 选中刚刚添加的maven，并Apply。4、 打开Window->Preferences->Maven->User Settings，配置如下并Apply：至此，Maven的安装和配置全部结束。"},{"title":"Sublime Text3常用插件","url":"/article/SublimeText3","content":"Sublime Text3常用插件 - ChineseLocalizations一种让Sublime汉化的插件Emmet（原名 Zen Coding）一种快速编写html/css的方法BracketHighlighter类似于代码匹配，可以匹配括号，引号等符号内的范围。AutoprefixerCSS3 私有前缀自动补全插件，显然也很有用哇HTML-CSS-JS Prettify使用说明：快速格式化html css js快捷键：ctrl+shift+hColorpicker使用一个取色器改变颜色快捷键：ctrl+shift+cSyncedSidebarBg自动同步侧边栏底色为编辑窗口底色Doc​Blockr注释插件，生成幽美的注释。标准的注释，包括函数名、参数、返回值等，并以多行显示，省去手动编写。使用方法见：输入/*、/**回车详情见：https://packagecontrol.io/packages/DocBlockrAutoFileName功能：文件路径补全简介：文件名输入补全，例如图片路径使用：输入”/“即可看到本项目文件夹的其他文件SublimeCodeIntelJavaScript自动补全设置方法进入SublimeText3—>Preferences—>Package Settings—>SublimeCodeIntel—>Settings-Default"},{"title":"Next-Hexo主题的多种样式配置","url":"/article/Next-Hexo主题的多种样式配置","content":"Next-Hexo主题的多种样式配置 - 添加404界面在source文件夹新建404.html，内容如下：\t---\tlayout: false\ttitle: \"404\"\t---\t\t\t\t    404 - No-Sky'blog\t    \t    \t    \t    \t    \t\t\t    \t\t添加本地搜索功能首先安装 hexo-generator-searchdb，在站点的根目录下执行以下命令：\t$ npm install hexo-generator-searchdb --save编辑 站点配置文件，新增以下内容到任意位置：\tsearch:\t  path: search.xml\t  field: post\t  format: html\t  limit: 10000编辑 主题配置文件，启用本地搜索功能：（在next主题的最新版已经有了这个配置，所以只要找local_search，把false改成true）\t# Local search\tlocal_search:\t  enable: true修改标签样式修改文章底部的那个带#号的标签实现效果图具体实现方法修改模板/themes/next/layout/_macro/post.swig，搜索 rel=\"tag\">#，将#换成网站底部字数统计实现效果图具体方法实现切换到根目录下，然后运行如下代码$ npm install hexo-wordcount --save然后在/themes/next/layout/_partials/footer.swig文件尾部加上：\t\t  \t  博客全站共{{ totalcount(site) }}字\t添加 README.md 文件每个项目下一般都有一个 README.md 文件，但是使用 hexo 部署到仓库后，项目下是没有 README.md 文件的。在 Hexo 目录下的 source 根目录下添加一个 README.md 文件，修改站点配置文件 _config.yml，将 skip_render 参数的值设置为\tskip_render: README.md保存退出即可。再次使用 hexo d 命令部署博客的时候就不会在渲染 README.md 这个文件了点击爆炸效果实现效果图实现方法:跟那个红心是差不多的，首先在themes/next/source/js/src里面建一个叫fireworks.js的文件，代码如下：\t\"use strict\";function updateCoords(e){pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top}function setParticuleDirection(e){var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return{x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)}}function createParticule(e,t){var a={};return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function(){ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()},a}function createCircle(e,t){var a={};return a.x=e,a.y=t,a.color=\"#F00\",a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function(){ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1},a}function renderParticule(e){for(var t=0;t \t    \t   \t{% endif %}打开主题配置文件，在里面最后写下：\t# Fireworks\t   fireworks: true更多的请参考Net主题配置"},{"title":"Git连接github超时问题解决方案","url":"/article/Git连接github超时问题解决方案","content":"Git连接github超时问题解决方案 - 因为电脑重新装了几次了导致  Git连接github时出现 了超时问题 ，如下：ssh: connect to host github.com port 22: Connection timed out    #使用ssh连接github时,出现timeout（Windows下）解决方案也很简单，修改ssh的配置文件。关于修改配置，存在两种解决方法，一种是C:\\Program Files\\Git\\etc\\ssh/ssh_config（你自己安装git的文件夹下面找）中修改全局配置，一种是在用户主目录下.ssh/中添加配置文件，这里我选择的后者（前者也可以解决问题，其实都可以）在Administrator/.ssh文件夹下新建config文件，注意，文件名就是config，没有后缀名添加一下内容（在全局文件中同样是这个方案）：\tHost github.com\tUser git\tHostname ssh.github.com\tPreferredAuthentications publickey\tIdentityFile ~/.ssh/id_rsa\tPort 443"},{"title":"Mybatis-generator之mybatis的快速使用","url":"/article/Mybatis-generator之mybatis的快速使用","content":"Mybatis-generator之mybatis的快速使用 - mybatis-generator插件自动生成单表的类和映射文件1、 下载mybatis-generrator插件包mybatis-generator-core-1.3.2目录结构：    docs    //说明文档文件夹    lib        //jar包文件夹    LICENSE        NOTICE    README.txt2、 配置mybatis-generator插件在lib文件夹下有一个generatorConfig.xml文件用NotePad++打开：\t  \t  \t  \t  \t      \t          \t          \t          \t      \t      \t      \t      \t      \t          \t      \t      \t      \t          \t          \t      \t      \t      \t          \t      \t      \t      \t          \t      \t      \t    \t  \t 按照注释修改自己的信息即可3、 使用mybatis-generator在lib文件夹下面按住shift键点击鼠标右键，点击在此处打开命令窗口输入一下命令：java -jar mybatis-generator-core-1.3.2.jar -configFile generatorConfig.xml  -overwrite生成的文件在lib文件下面的src文件夹中"},{"title":"Mybatis之多表查询","url":"/article/Mybatis之多表查询","content":"Mybatis之多表查询 - Mybatis详解第三弹——联表查询** 一对一 **创建表和数据：\tCREATE TABLE teacher(\t\tt_id INT PRIMARY KEY AUTO_INCREMENT, \t\tt_name VARCHAR(20)\t);\tCREATE TABLE class(\t\tc_id INT PRIMARY KEY AUTO_INCREMENT, \t\tc_name VARCHAR(20), \t\tteacher_id INT\t);\tALTER TABLE class ADD CONSTRAINT fk_teacher_id FOREIGN KEY (teacher_id) REFERENCES teacher(t_id);    \tINSERT INTO teacher(t_name) VALUES('LS1');\tINSERT INTO teacher(t_name) VALUES('LS2');\tINSERT INTO class(c_name, teacher_id) VALUES('bj_a', 1);\tINSERT INTO class(c_name, teacher_id) VALUES('bj_b', 2);定义实体类：\tpublic class Teacher {\t    private int id;\t    private String name;\t}\tpublic class Classes {\t    private int id;\t    private String name;\t    private Teacher teacher;\t}c. 定义sql映射文件ClassMapper.xml：方式一：嵌套查询方式, 通过执行另外一个SQL映射语句来返回预期的复杂类型\t\t    select * from class where c_id=#{id}\t\t\t    \t    \t    \t\t\t    select t_id id, t_name name from teacher where t_id=#{id}\t方式二：嵌套结果：使用嵌套结果映射来处理重复的联合结果的子集\t \t        select * from class c,teacher t where c.c_id=#{id} and c.teacher_id=t.t_id; \t\t\t    \t    \t    \t        \t        \t    \td. 测试：\t@Test\tpublic void testQueryOO() {\t    SqlSession session = factory.openSession();\t    Classes c = sqlSession.selectOne(\"com.test.CTMapper.getClasses\", 1);\t    System.out.println(c);\t}\t@Test\tpublic void testQueryOO2() {\t    SqlSession session = factory.openSession();\t    Classes c = sqlSession.selectOne(\"com.test.CTMapper.getClasses2\", 1);\t    System.out.println(c);\t}** 一对多 **创建表：\tCREATE TABLE student(\t\ts_id INT PRIMARY KEY AUTO_INCREMENT, \t\ts_name VARCHAR(20), \t\tclass_id INT\t);\tINSERT INTO student(s_name, class_id) VALUES('xs_B', 1);\tINSERT INTO student(s_name, class_id) VALUES('xs_D', 1);\tINSERT INTO student(s_name, class_id) VALUES('xs_E', 1);\tINSERT INTO student(s_name, class_id) VALUES('xs_A', 2);\tINSERT INTO student(s_name, class_id) VALUES('xs_H', 2);\tINSERT INTO student(s_name, class_id) VALUES('xs_J', 2);定义实体类：\tpublic class Student {\t    private int id;\t    private String name;\t}\tpublic class Classes {\t    private int id;\t    private String name;\t    private Teacher teacher;\t    private List students;\t}定义sql映射文件ClassMapper.xml：(根据classId查询对应的班级信息,包括学生)集合的嵌套结果：使用嵌套结果映射来处理重复的联合结果的子集\t \t        select * from class c,teacher t, student s where c.c_id=#{id} and c.teacher_id=t.t_id and s.class_id=c.c_id \t\t\t    \t    \t    \t        \t        \t    \t    \t        \t        \t    \t集合的嵌套查询方式, 通过执行另外一个SQL映射语句来返回预期的复杂类型\t\t        select * from class c where c.c_id=#{id}\t\t\t    \t    \t    \t    \t\t\t    select t_id id, t_name name from teacher where t_id=#{id}\t\t\t    select s_id id, s_name name from student where class_id=#{id}\t测试：\t@Test\tpublic void testQueryOT() {\t    SqlSession session = factory.openSession();\t    Classes classes = openSession.selectOne(\"com.test.OMMapper.getClasses3\", 1);\t    System.out.println(c);\t}\t@Test\tpublic void testQueryOT2() {\t    SqlSession session = factory.openSession();\t    Classes classes = openSession.selectOne(\"com.test.OMMapper.getClasses4\", 1);\t    System.out.println(c);\t}"},{"title":"Mybatis之优化XML配置","url":"/article/Mybatis之优化XML配置","content":"Mybatis之优化XML配置 - Mybatis详解第三弹——优化xml配置使用** 数据库配置优化 **原：    \t    \t            \t            \t                \t                \t                \t                \t        \t         把对应的数据库配置信息写到一个properties文件中去db.propertise       driver=oracle.jdbc.driver.OracleDriver       url=jdbc:oracle:thin:@127.0.0.1:1521:ORCL       username=scott       password=tiger改：                                                                                                                                         ** 为实体类定义别名,简化sql映射xml文件中的引用 **\t\t    \t  注意： 将要使用的别名配置写在mybatis配置文件中而不是实体映射文件添加log4j.jar，打印日志信息在src目录下以下文件log4j.properties    log4j.rootLogger=DEBUG, Console    #Console    log4j.appender.Console=org.apache.log4j.ConsoleAppender    log4j.appender.Console.layout=org.apache.log4j.PatternLayout    log4j.appender.Console.layout.ConversionPattern=%d [%t] %-5p [%c] - %m%n    log4j.logger.java.sql.ResultSet=INFO    log4j.logger.org.apache=INFO    log4j.logger.java.sql.Connection=DEBUG    log4j.logger.java.sql.Statement=DEBUG    log4j.logger.java.sql.PreparedStatement=DEBUGlog4j.xml                                                                                                                                                                        ** 解决表的字段名与实体类的属性名不相同的冲突 **a. 准备表和数据：    CREATE TABLE orders(        order_id INT PRIMARY KEY AUTO_INCREMENT,        order_no VARCHAR(20),         order_price FLOAT    );    INSERT INTO orders(order_no, order_price) VALUES('aaaa', 23);    INSERT INTO orders(order_no, order_price) VALUES('bbbb', 33);    INSERT INTO orders(order_no, order_price) VALUES('cccc', 22);b. 定义实体类：    public class Order {        private int id;        private String orderNo;        private float price;    }c. 实现getOrderById(id)的查询c1. 通过在sql语句中定义别名            select order_id id, order_no orderNo,order_price price from orders where order_id=#{id}    c2. 定义            select * from orders where order_id=#{id}                                    "},{"title":"Mybatis之CRUD操作","url":"/article/Mybatis之CRUD操作","content":"Mybatis之CRUD操作 - Mybatis详解第二弹——编写基于mybatis的操作Emp表的CRUD操作的dao类用xml配置的方式1、定义sql映射的xml文件 如：\tid: 是sql语句在xml文件的位置\tparameterType: 需要传递参数的类型\tresultType: sql语句执行后返回的类型 \t\t    select * from emp where ename = #{ename};\t\t\t    insert into emp values (#{empno,#{ename},#{job},#{mgr},#{hiredate},#{sql},#{comm},#{deptno})\t            \t\t    delete from emp where empno = #{empno}\t\t\t    update emp set ename=#{ename},job=#{job},... where empno=#{empno} \t2、在mybatis配置文件中注册实体对应的SQL映射\t\t    \t3、在dao中使用\tpublic Emp getEmpByName(String ename) {\t        创建SessionFactory的代码省略\t        SqlSession session = sessionFactory.openSession();\t        User user = session.selectOne(\"com.mapper.EmpMapper.getEmpByName\", ename);\t        return Emp;\t    }\t    .........用注解的方式1、 定义SQL映射的接口\tpublic interface EmpMapper {\t    @Select(\"select * from emp where ename = #{ename}\")\t    public Emp getEmpByName(String name);\t    @Delete(\"delete from emp where empno = #{empno}\")\t    public int deleteByNo(int empno);\t    @Insert(\"insert into emp values (#{empno,#{ename},#{job},#{mgr},#{hiredate},#{sql},#{comm},#{deptno})\")\t    public int insertEmp(Emp emp);\t    @Update(\"update emp set ename=#{ename},job=#{job},... where empno=#{empno} \")\t    public int updateBuNo(Emp emp);\t}2、在mybatis配置文件中注册实体对应的SQL映射    3、在dao中使用\tpublic Emp getEmpByName(String ename) {\t        创建SessionFactory的代码省略\t        SqlSession session = sessionFactory.openSession();\t        EmpMapper mapper = session.getMapper(EmpMapper.class);\t        Emp emp = mapper.getEmpByNo\t        return Emp;\t    }\t    ......."},{"title":"Mybatis初识","url":"/article/Mybatis初识","content":"Mybatis初识 - Mybatis详解第一弹——初识Mybatis初识*​\tMyBatis是支持普通SQL查询，存储过程和高级映射的优秀持久层框架。MyBatis消除​\t了几乎所有的JDBC代码和参数的手工设置以及对结果集的检索。MyBatis可以使用简单的​\tXML或注解用于配置和原始映射，将接口和Java的POJO（Plain Old Java Objects，普通的​\tJava对象）映射成数据库中的记录。*Mybatis简单使用1、引入jar包*​\tmybatis-3.1.1.jar​\tlog4j-1.2.16.jar​\tojdbc5.jar*2、创建数据库和表为了更简单的创建一个实例，我使用了Oracle的scoot账户，直接使用emp表作为示例3、 在示例项目下添加mybatis配置文件 mybatis-conf.xml (命名随意)\t\t\t\t\t    \t    \t    \t        \t        \t        \t        \t    \t    \t\t\t              //在mybatis-cong.xml中注册EmpMapper.xml文件\t\t4、 创建数据表对应的实体 如：Emp.java\t    public class Emp {\t        private int empno;\t        private String ename;\t        private String job;\t        private int mgr;\t        private Date hiredate;\t        private float sal;\t        private float comm;\t        private int deptno;\t        //get与set方法省略\t    }5、 创建实体对应的sql映射文件EmpMapper.xml\t\t\t     //Mappper映射文件所在位置\t         //xml方式配置sql语句\t        select * from emp\t    \t6、 在mybatis-cong.xml中注册EmpMapper.xml文件\t \t    \t7、 编写测试代码，执行预定义的select语句\tpublic class EmpMapperTest {\t    public static void main(String[] args) {\t        String resource = \"conf.xml\"; \t        //加载mybatis的配置文件（它也加载关联的映射文件）\t        Reader reader = Resources.getResourceAsReader(resource); \t        //构建sqlSession的工厂\t        SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(reader);\t        //创建能执行映射文件中sql的sqlSession\t        SqlSession session = sessionFactory.openSession();\t        //映射sql的标识字符串\t        String statement = \"com.mapper.EmpMapper.getEmps\";\t        List list = new ArrayList();\t        list = session.selectList(statement);\t        System.out.println(list);\t    }\t}"},{"title":"用Java生成二维码","url":"/article/用Java生成二维码","content":"用Java生成二维码 - java实现二维码开发java开发二维码的流程1、导入核心jar包，在这里使用Google的zxing.jar，还有一个是日本开发qrcode就不用了。\tcore-3.1.0.jar2、编写二维码核心类\tpublic static void zxingImg(String content,HttpServletResponse response) throws IOException{\t    int width2 = 200;   //图片高度和宽度\t    int height2 = 200; \t    //二维码的图片格式 \t    String format = \"gif\"; \t    Hashtable hints = new Hashtable(); \t    //内容所使用编码 \t    hints.put(EncodeHintType.CHARACTER_SET, \"UTF-8\"); \t    try {\t\t    BitMatrix bitMatrix = new MultiFormatWriter().encode(content,BarcodeFormat.QR_CODE, width2, height2, hints);\t\t    int width = bitMatrix.getWidth(); \t\t    int height = bitMatrix.getHeight(); \t\t    BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB); \t\t\t    for (int x = 0; x \" />"},{"title":"Oracle笔记——游标、存储过程","url":"/article/Oracle笔记——游标、存储过程","content":"Oracle笔记——游标、存储过程 - 游标、存储过程##一、游标参数的传递例：SET SERVEROUTPUT ONDECLARE    V_empno NUMBER(5);\tV_ename VARCHAR2(10);\tCURSOR \temp_cursor(p_deptno NUMBER,p_job VARCHAR2) IS SELECT empno,ename FROM emp WHERE\tdeptno = p_deptno AND job = p_job;BEGIN \tOPEN emp_cursor(10, 'CLERK');  \tLOOP  \t   FETCH emp_cursor INTO v_empno,v_ename;  \tEXIT WHEN emp_cursor%NOTFOUND;  \t   DBMS_OUTPUT.PUT_LINE(v_empno||','||v_ename);\tEND LOOP;END; 二、异常处理错误处理的语法如下：EXCEPTIONWHEN 错误1[OR 错误2] THEN 语句序列1;WHEN 错误3[OR 错误4] THEN 语句序列2;...WHEN OTHERS 语句序列n;  END;例：SET SERVEROUTPUT ONDECLARE    v_name VARCHAR2(10);BEGIN    SELECT\tename  INTO v_name  FROM emp  WHERE\tempno = 1234;DBMS_OUTPUT.PUT_LINE('该雇员名字为：'|| v_name);EXCEPTION\t\tWHEN NO_DATA_FOUND THEN\tDBMS_OUTPUT.PUT_LINE('编号错误，没有找到相应雇员！');\t\tWHEN OTHERS THEN DBMS_OUTPUT.PUT_LINE('发生其他错误！');END;三、存储过程创建和删除存储过程格式： CREATE [OR REPLACE] PROCEDURE 存储过程名[(参数[IN|OUT|IN OUT] 数据类型...)]{AS|IS}\t[说明部分]   --定义需要使用的临时变量BEGIN\t语句集;\t[EXCEPTION]\t    [错误处理部分]END [过程名];删除：drop procedure 存储过程名;调用存储过程方法1：EXECUTE 模式名.存储过程名[(参数...)];   (适用于命今行窗口及sql窗口)方法2： (适用于sql窗口)BEGIN  模式名.存储过程名[(参数...)];END;例：编写显示雇员信息的存储过程EMP_LIST，并引用EMP_COUNT存储过程(无参存储过程 )。CREATE OR REPLACE PROCEDURE EMP_LISTAS   CURSOR emp_cursor IS SELECT empno,ename FROM emp;BEGIN\tFOR Emp_record IN emp_cursor LOOP   \t\t\tDBMS_OUTPUT.PUT_LINE(Emp_record.empno||Emp_record.ename);\tEND LOOP;\tEMP_COUNT;END;调用：begin\tEMP_LIST;end;参数传递a.输入参数: 参数名  IN 数据类型 DEFAULT 值；例：编写给雇员增加工资的存储过程CHANGE_SALARY，通过IN类型的参数传递要增加工资的雇员编号和增加的工资额。CREATE OR REPLACE PROCEDURE CHANGE_SALARY(P_EMPNO IN NUMBER DEFAULT 7788,P_RAISE NUMBER DEFAULT 10)  --形参P_EMPNO及P_RAISEAS   V_ENAME VARCHAR2(10);   V_SAL NUMBER(5);BEGIN\t   SELECT ENAME,SAL INTO V_ENAME,V_SAL FROM EMP WHERE EMPNO=P_EMPNO;   UPDATE EMP SET SAL=SAL+P_RAISE WHERE EMPNO=P_EMPNO;   DBMS_OUTPUT.PUT_LINE('雇员'||V_ENAME||'的工资被改为'||TO_CHAR(V_SAL+P_RAISE));   COMMIT;EXCEPTION  WHEN OTHERS THEN DBMS_OUTPUT.PUT_LINE('发生错误，修改失败！');  ROLLBACK; --如果出了异常则撤消END;调用：begin\tCHANGE_SALARY(7788,80)end;b.输出参数: 参数名 OUT 数据类型 DEFAULT  值；—例：统计雇员的人数CREATE OR REPLACE PROCEDURE EMP_COUNT(P_TOTAL OUT NUMBER)   --P_TOTAL为输出参数ASBEGIN\tSELECT COUNT(*) INTO P_TOTAL FROM EMP;END;调用：DECLAREV_EMPCOUNT NUMBER;   --定义变量接收过程求出的结果BEGIN\tEMP_COUNT(V_EMPCOUNT);\tDBMS_OUTPUT.PUT_LINE('雇员总人数为：'||V_EMPCOUNT);END;c.输入输出参数： 参数名  IN OUT   数据类型   DEFAULT   值；—例：使用IN OUT类型的参数，给电话号码增加区码。CREATE OR REPLACE PROCEDURE ADD_REGION(P_HPONE_NUM IN OUT VARCHAR2)ASBEGIN   P_HPONE_NUM:='024-'||P_HPONE_NUM;END;调用：DECLARE\tV_PHONE_NUM VARCHAR2(15);BEGIN\tV_PHONE_NUM:='26731092';\tADD_REGION(V_PHONE_NUM);\tDBMS_OUTPUT.PUT_LINE('新的电话号码：'||V_PHONE_NUM);END;"},{"title":"Oracle笔记——PL/SQL空值语句、游标","url":"/article/Oracle笔记——PL/SQL空值语句-游标","content":"Oracle笔记——PL/SQL空值语句、游标 - PL/SQL空值语句、游标一、IF语句1、IF-THEN-END IF形式   IF 条件 then        语句集;   END IF;2、IF-THEN-ELSE-END IF形式   IF 条件 then        语句集1;   ElSE       语句集2   END IF;3．IF-THEN-ELSIF-ELSE-END IF形式   IF 条件1 THEN\t语句集1;   ELSIF 条件2 THEN\t语句集2;   ELSIF 条件3 THEN\t语句集3;   ...   ELSE\t语句集n;   END IF;##二、CASE语句1．基本CASE结构   CASE 变量或表达式   When 值1 then 结果1;   When 值2 then 结果2;   When 值3 then 结果3;   ...   ELSE 结果n;   END CASE;2.搜索CASE结构  CASE    When 条件1 then 结果1;   When 条件2 then 结果2;   When 条件3 then 结果3;   ...   ELSE 结果n;   END CASE;三、循环1．基本LOOP循环   loop      语句集;   exit when 条件      语句集;   end loop;2.FOR LOOP循环FOR循环是固定次数循环，格式如下：\tFOR 控制变量 in [REVERSE] 下限..上限 \t\tLOOP  \t\t \t语句集;  \t\tEND LOOP;注：循环控制变量是隐含定义的，不需要声明。​下限和上限用于指明循环次数。正常情况下循环控制变量的取值由下限到上限递增，REVERSE关键字表示循环控制变量的取值由上限到下限递减。3．WHILE LOOP循环   while 条件 loop       语句集;   end loop;四、游标1、概念游标是SQL的一个内存工作区，由系统或用户以变量的形式定义。游标的作用就是用于临时存储从数据库中提取的数据块。在某些情况下，需要把数据从存放在磁盘的表中调到计算机内存中进行处理，最后将处理结果显示出来或最终写回数据库。这样数据处理的速度才会提高，否则频繁的磁盘数据交换会降低效率。游标有两种类型：显式游标和隐式游标。在前述程序中用到的SELECT…INTO…查询语句，一次只能从数据库中提取一行数据，系统都会使用一个隐式游标。显式游标对应一个返回结果为多行多列的SELECT语句。游标一旦打开，数据就从数据库中传送到游标变量中，然后应用程序再从游标变量中分解出需要的数据，并进行处理。2、隐式游标属性隐式游标的属性返回值类型意义SQL%ROWCOUNT整型代表DML语句成功执行的数据行数SQL%FOUND布尔型值为TRUE代表插入、删除、更新或单行查询操作成功SQL%NOTFOUND布尔型与SQL%FOUND属性返回值相反SQL%ISOPEN布尔型DML执行过程中为真，结束后为假如：使用隐式游标的属性，判断对雇员工资的修改是否成功。SET SERVEROUTPUT ON \t\tBEGIN  \t\tUPDATE emp SET sal=sal+100 WHERE empno=1234;\t\t IF SQL%FOUND THEN  \t\tDBMS_OUTPUT.PUT_LINE('成功修改雇员工资！');  \t\tCOMMIT;  \t\tELSEDBMS_OUTPUT.PUT_LINE('修改雇员工资失败！');\t\t END IF; \t\tEND;3、显式游标游标的使用分成以下4个步骤。a．声明游标在DECLEAR部分按以下格式声明游标：CURSOR 游标名[(参数1 数据类型[，参数2 数据类型...])]\t\t IS SELECT语句;参数是可选部分，所定义的参数可以出现在SELECT语句的WHERE子句中。如果定义了参数，则必须在打开游标时传递相应的实际参数。b.打开游标在可执行部分，按以下格式打开游标：OPEN 游标名[(实际参数1[，实际参数2...])];打开游标时，SELECT语句的查询结果就被传送到了游标工作区。c.提取数据在可执行部分，按以下格式将游标工作区中的数据取到变量中。提取操作必须在打开游标之后进行。\tFETCH 游标名 INTO 变量名1[，变量名2...];或\tFETCH 游标名 INTO 记录变量;游标打开后有一个指针指向数据区，FETCH语句一次返回指针所指的一行数据，要返回多行需重复执行，可以使用循环语句来实现。控制循环可以通过判断游标的属性来进行。定义记录变量的方法如下：变量名 表名|游标名%ROWTYPE；d.关闭游标\tCLOSE 游标名;显式游标打开后，必须显式地关闭。游标一旦关闭，游标占用的资源就被释放，游标变成无效，必须重新打开才能使用。【例1】 用游标提取emp表中7788雇员的名称和职务。SET SERVEROUTPUT ON\t     --在命令行界面是必须的，在第三方工具的SQL界面中无需此语句DECLARE\t\t    v_ename VARCHAR2(10);\t    v_job VARCHAR2(10);\t    CURSOR emp_cursor IS  SELECT ename,job FROM emp WHERE empno=7788;BEGIN    OPEN emp_cursor;    FETCH emp_cursor INTO v_ename,v_job;\t    DBMS_OUTPUT.PUT_LINE(v_ename||','||v_job);    CLOSE emp_cursor;\tEND;【例2】  用游标提取emp表中7788雇员的姓名、职务和工资。SET SERVEROUTPUT ON\t     --在命令行界面是必须的，在第三方工具的SQL界面中无需此语句DECLARE\t \tCURSOR emp_cursor IS  SELECT ename,job,sal FROM emp WHERE empno=7788;\temp_record emp_cursor%ROWTYPE;\t    --用游标定义记录变量\tBEGIN \tOPEN emp_cursor;\t\tFETCH emp_cursor INTO emp_record;  \t DBMS_OUTPUT.PUT_LINE(emp_record.ename||','|| emp_record.job||','|| emp_record.sal);\t\t CLOSE emp_cursor;\tEND;【例3】  显示工资最高的前3名雇员的名称和工资。SET SERVEROUTPUT ON\t\t   --在命令行界面是必须的，在第三方工具的SQL界面中无需此语句DECLARE\t\t V_ename VARCHAR2(10);\t\tV_sal NUMBER(5);\t\tCURSOR emp_cursor IS  SELECT ename,sal FROM emp ORDER BY sal DESC;\tBEGIN\t\t OPEN emp_cursor;\t FOR I IN 1..3 LOOP  \t\t FETCH emp_cursor INTO v_ename,v_sal;\t\t DBMS_OUTPUT.PUT_LINE(v_ename||','||v_sal);  END LOOP;   CLOSE emp_cursor;END;4、游标循环（重点）方法一：使用特殊的FOR循环形式显示全部雇员的编号和名称(省略掉定义记录变量、打开游标、提取数据、关闭游标)。SET SERVEROUTPUT ON     --在命令行界面是必须的，在第三方工具的SQL界面中无需此语句DECLARE \tCURSOR emp_cursor IS  SELECT empno, ename FROM emp;BEGIN\t\tFOR Emp_record IN emp_cursor LOOP   \t\t DBMS_OUTPUT.PUT_LINE(Emp_record.empno|| Emp_record.ename);\tEND LOOP;\tEND;方法二：最简单方式SET SERVEROUTPUT ON      --在命令行界面是必须的，在第三方工具的SQL界面中无需此语句BEGIN\t FOR re IN (SELECT ename FROM EMP)  LOOP\t\tDBMS_OUTPUT.PUT_LINE(re.ename)\tEND LOOP;END;5、利用游标属性做循环条件【训练1】  使用游标的属性练习。SET SERVEROUTPUT ON         --在命令行界面是必须的，在第三方工具的SQL界面中无需此语句DECLARE  V_ename VARCHAR2(10);  CURSOR emp_cursor IS   SELECT ename FROM emp;BEGIN\t  OPEN emp_cursor;\t   IF emp_cursor%ISOPEN THEN  LOOP    FETCH emp_cursor INTO v_ename;\t            EXIT WHEN emp_cursor%NOTFOUND;    DBMS_OUTPUT.PUT_LINE(to_char(emp_cursor%ROWCOUNT)||'-'||v_ename);\t        END LOOP;  ELSE    DBMS_OUTPUT.PUT_LINE('用户信息：游标没有打开！');  END IF;           CLOSE  emp_cursor;END;"},{"title":"Oracle笔记——索引、同义词、数据库链接、PLSQL语句","url":"/article/Oracle笔记——索引-同义词-数据库链接-PLSQL语句","content":"Oracle笔记——索引、同义词、数据库链接、PLSQL语句 - 索引、同义词、数据库链接、PL/SQL语句一、索引索引(INDEX)是为了加快数据的查找而创建的数据库对象，特别是对大表，索引可以有效地提高查找速度，也可以保证数据的惟一性创建索引一般要掌握以下原则：只有较大的表才有必要建立索引，表的记录应该大于50条，查询数据小于总行数的2%～4%。虽然可以为表创建多个索引，但是无助于查询的索引不但不会提高效率，还会增加系统开销。因为当执行DML操作时，索引也要跟着更新，这时索引可能会降低系统的性能。创建索引：CREATE INDEX 索引名 ON 表名(列名);删除索引：DROP INDEX 索引名；二、同义词**   同义词(SYNONYM)是为模式对象起的别名，可以为表、视图、序列、过程、函数和包等数据库模式对象创建同义词。**创建私有同义词：CREATE SYNONYM BOOK FOR 图书；创建公有同义词(先要获得创建公有同义词的权限)：CREATE PUBLIC SYNONYM BOOK FOR SCOTT.图书；删除同义词：DROP SYNONYM 同义词名；三、数据库链接** 数据库链接(DATABASE LINK)是在分布式环境下，为了访问远程数据库而创建的数据通信链路。**格式：CREATE DATABASE LINK 链接名 CONNECT TO 账户 IDENTIFIED BY 口令 USING 服务名;数据库链接一旦建立并测试成功，就可以使用以下形式来访问远程用户的表。表名@数据库链接名四、PL/sql1、块结构和基本语法要求块中各部分的作用解释如下：(1)  DECLARE：声明部分标志。(2)  BEGIN：可执行部分标志。(3)  EXCEPTION：异常处理部分标志。(4)  END；：程序结束标志。2、输出第一种形式：DBMS_OUTPUT.PUT(字符串表达式)；第二种形式：DBMS_OUTPUT.PUT_LINE(字符串表达式)；第三种形式：DBMS_OUTPUT.NEW_LINE；3、变量赋值：第一种形式：SELECT 列名1，列名2... INTO 变量1，变量2... FROM 表名 WHERE 条件；第二种形式：变量名:=值例：查询雇员编号为7788的雇员姓名和工资。SET SERVEROUTPUT ON\t\t--在命令行界面必须写DECLARE--定义部分标识\t\t v_name  VARCHAR2(10);\t--定义字符串变量v_name\t\t v_sal   NUMBER(5);\t--定义数值变量v_sal\t\tBEGIN\t\t\t--可执行部分标识SELECT\t ename,sal INTO v_name,v_sal  FROM emp  WHERE empno=7788;--在程序中插入的SQL语句  \t\tDBMS_OUTPUT.PUT_LINE('7788号雇员是：'||v_name||'，工资为：'||to_char(v_sal));\t\t--输出雇员名和工资\t\tEND;\t4、结合变量的定义和使用（即全局变量）**  该变量是在整个SQLPlus环境下有效的变量，在退出SQLPlus之前始终有效，所以可以使用该变量在不同的程序之间传递信息。结合变量不是由程序定义的，而是使用系统命令VARIABLE定义的。**例：定义并使用结合变量步骤1：输入和执行下列命令，定义结合变量g_ename：--SET SERVEROUTPUT ON \tVARIABLE  g_ename VARCHAR2(100)\t\tBEGIN\t:g_ename:=:g_ename|| 'Hello~ ';\t\t\t--在程序中使用结合变量\tDBMS_OUTPUT.PUT_LINE(:g_ename);                --输出结合变量的值END;5．记录变量的定义还可以根据表或视图的一个记录中的所有字段定义变量，称为记录变量。记录变量包含若干个字段，在结构上同表的一个记录相同，定义方法是在表名后跟%ROWTYPE。记录变量的字段名就是表的字段名，数据类型也一致。如：v_name emp.ename%TYPE;"},{"title":"java中的foreach与js中的for in的区别","url":"/article/java中的foreach与js中的for in的区别","content":"java中的foreach与js中的for in的区别 - js里的for in循环定义如下：代码如下:\tfor(var variable in obj) { ... }obj可以是一个普通的js对象或者一个数组。如果obj是js对象，那么variable在遍历中得到的是对象的属性的名字，而不是属性对应的值。如果obj是数组，那么variable在遍历中得到的是数组的下标。遍历对象实验：代码如下:\tvar v = {};  \tv.field1 = \"a\";  \tv.field2 = \"b\";  \tfor(var v in v) {      \tconsole.log(v);  \t}控制台下输出：\tfield1\tfield2遍历数组实验：代码如下:\tvar mycars = new Array()\tmycars[0] = \"Saab\"\tmycars[1] = \"Volvo\"\tmycars[2] = \"BMW\"\t  \tfor (var x in mycars){\t  console.log(x);\t}控制台输出：\t0\t1\t2拿java的foreach循环来做对比，有两大差别。首先java的foreach循环不会去枚举一个java对象的属性。其次，java的foreach循环枚举一个数组或者任何实现了Iterable接口的对象的时候，for(Object o : list), 对象o得到的是list一个元素，而非在列表中的下标。java的遍历代码就不贴出来了。经常写后台代码，foreach循环很熟悉。写前台js代码的时候，难免会套用java的语法，所以第一次用js的for in循环的时候犯错了。"},{"title":"Oracle笔记——分区、视图","url":"/article/Oracle笔记——分区-视图","content":"Oracle笔记——分区、视图 - 分区、视图一、分区表在某些场合会使用非常大的表，比如人口信息统计表。如果一个表很大，就会降低查询的速度，并增加管理的难度。一旦发生磁盘损坏，可能整个表的数据就会丢失，恢复比较困难。根据这一情况，可以创建分区表，把一个大表分成几个区(小段)，对数据的操作和管理都可以针对分区进行，这样就可以提高数据库的运行效率。分区可以存在于不同的表空间上，提高了数据的可用性。例：创建和使用分区表。​如：创建按成绩分区的考生表，共分为3个区：\t\tCREATE TABLE 考生 (\t考号 VARCHAR2(5),\t\t\t姓名 VARCHAR2(30),\t\t\t成绩 NUMBER(3)\t\t)PARTITION BY RANGE(成绩)​\t\t(PARTITION A VALUES LESS THAN (300)​\t\tTABLESPACE USERS,​\t\tPARTITION B VALUES LESS THAN (500)​\t\tTABLESPACE USERS,​\t\tPARTITION C VALUES LESS THAN (MAXVALUE)​\t\tTABLESPACE USERS​\t\t);步骤3：检查A区中的考生：SELECT *  FROM  考生 PARTITION(A);步骤4：检查全部的考生：SELECT *  FROM  考生;二、视图1、视图的概念视图不同于表，视图本身不包含任何数据。而视图只是一种定义，对应一个查询语句。视图的数据都来自于某些表，这些表被称为基表。    视图可以在表能够使用的任何地方使用，但在对视图的操作上同表相比有些限制，特别是插入和修改操作。对视图的操作将传递到基表，所以在表上定义的约束条件和触发器在视图上将同样起作用。2、视图的创建2、格式：create [or replace] view 视图名 asselect 语句;例：创建图书作者视图：CREATE VIEW 图书作者(书名,作者) \t\tAS SELECT 图书名称,作者 FROM 图书;查询视图全部内容SELECT * FROM 图书作者;    查询部分视图：SELECT 作者 FROM 图书作者;删除视图：DROP VIEW 清华图书;3．创建只读视图创建只读视图要用WITH READ ONLY选项。​例：创建emp表的经理视图：CREATE OR REPLACE VIEW manager \tAS SELECT * FROM emp WHERE job= 'MANAGER'\tWITH READ ONLY;4．使用WITH CHECK OPTION选项使用WITH CHECK OPTION选项。使用该选项，可以对视图的插入或更新进行限制，即该数据必须满足视图定义中的子查询中的WHERE条件，否则不允许插入或更新。例：CREATE OR REPLACE VIEW 清华图书 \t\t\tAS SELECT * FROM 图书 WHERE 出版社编号= '01'WITH CHECK OPTION;注：插入数据时，由于带了with check option的选项，则只能插入出版社编为’01’的数据5．来自基表的限制除了以上的限制，基表本身的限制和约束也必须要考虑。如果生成子查询的语句是一个分组查询，或查询中出现计算列，这时显然不能对表进行插入。另外，主键和NOT NULL列如果没有出现在视图的子查询中，也不能对视图进行插入。在视图中插入的数据，也必须满足基表的约束条件。6.视图的查看USER_VIEWS字典中包含了视图的定义。​USER_UPDATABLE_COLUMNS字典包含了哪些列可以更新、插入、删除。​USER_OBJECTS字典中包含了用户的对象。​可以通过DESCRIBE命令查看字典的其他列信息。例：查看用户拥有的视图：SELECT object_name FROM user_objects WHERE object_type='VIEW';"},{"title":"Oracle笔记——建表","url":"/article/Oracle笔记——建表","content":"Oracle笔记——建表 - 建表一、建表格式：create table 表名      (\t  列名1   类型   约束,\t  列名2   类型   约束,\t  ......\t\t\t      );如：—创建出版社表\tcreate table 出版社（\t\t编号 varchar2(2),\t\t出版社名称 varchar2(30),\t\t地址 varchar2(30),\t\t联系电话 varchar2(20)\t）;—创建图书表\tcreate table 图书 (\t\t图书编号 VARCHAR2(5),\t\t图书名称 VARCHAR2(30),\t\t出版社编号 VARCHAR2(2),\t\t作者 VARCHAR2(10),\t\t出版日期 DATE,\t\t数量 NUMBER(3),\t\t单价 NUMBER(7,2)\t\t);二、通过子查询建表步骤1：完全复制图书表到“图书1”create table 图书1 as select * from 图书;步骤2：创建新的图书表“图书2”，只包含书名和单价create table 图书2（书名，单价） as seelct 图书名称，单价 from 图书；步骤3：创建新的图书表“图书3”，只包含书名和单价，不复制内容create table 图书3（书名，单价） as select 图书名称，单价 from 图书 where 1=2；三、添加表的约束主键     primary key      PK唯一     unique           UQ默认值   default          DF检查约束 check            CK外键约束 foreign key      FK方法一：建表的同时添加约束如：create table stuinfo( sno int primary key not null,       --主键 sname varchar2(10) unique not null,       --唯一 sex char(2) default '男' check(sex='男' or sex = '女') not null,   --默认及检查 saddress varchar2(50) not null, phone char(11), email varchar2(50));create table stumarks( marksId int, sno int references stuinfo(sno) not null,     --外键 score number(5,1), examDate date default sysdate);方法二，再添加约束如：（之前已建好了出版社表及图书表）—主键约束alter table 出版社 add constraint PK_编号 primary key (编号);—唯一约束alter table 出版社 add constraint UQ_地址 unique (地址);—检查约束alter table 出版社 add constraint CK_联系电话 check (联系电话 like '1%');—默认值alter table 出版社 modify 地址 default '湘潭';—外键约束alter table 图书 add constraint FK_图书编号 foreign key (图书编号) references 出版社(编号);—外键约束alter table 图书 add constraint FK_图书编号 foreign key (图书编号) references 出版社(编号);四、查看约束条件数据字典USER_CONSTRAINTS中包含了当前模式用户的约束条件信息。其中，CONSTRAINTS_TYPE 显示的约束类型为：\t\tC：CHECK约束。P：PRIMARY KEY约束。​\t\tU：UNIQUE约束。​\t\tR：FOREIGN KEY约束。\t其他信息可根据需要进行查询显示，可用DESCRIBE命令查看USER_CONSTRAINTS的结构。如：SELECT CONSTRAINT_NAME,CONSTRAINT_TYPE,SEARCHCONDITONFROM USER_CONSTRAINTSWHERE TABLE_NAME='图书';五、删除约束条件ALTER TABLE 表名 DROP CONSTRAINT 约束名;六、表的操作1、删除表    drop table 表名2、重命名表  RENAME 表名 TO 新表名;3、查看表可以通过对数据字典USER_OBJECTS的查询，显示当前模式用户的所有表。​如： 显示当前用户的所有表。SELECT object_name FROM user_objects WHERE object_type='TABLE';七、修改表1、增加新列:如： 为“出版社”增加一列“电子邮件”：ALTER TABLE 出版社\t\tADD 电子邮件 VARCHAR2(30) CHECK(电子邮件 LIKE '%@%');2、修改列修改列定义有以下一些特点：(1) 列的宽度可以增加或减小，在表的列没有数据或数据为NULL时才能减小宽度。(2) 在表的列没有数据或数据为NULL时才能改变数据类型，CHAR和VARCHAR2之间可以随意转换。(3) 只有当列的值非空时，才能增加约束条件NOT NULL。(4) 修改列的默认值，只影响以后插入的数据。如：修改“出版社”表“电子邮件”列的宽度为40。\tALTER TABLE 出版社 MODIFY 电子邮件 VARCHAR2(40);3、删除列如：删除“出版社”表的“电子邮件”列。ALTER TABLE 出版社 DROP COLUMN 电子邮件;"},{"title":"Oracle笔记——表的增删改操作","url":"/article/Oracle笔记——表的增删改操作","content":"Oracle笔记——表的增删改操作 - 表的增删改操作一、增删改增： insert into 表名(列名) values (值)；删： delete from 表名 where 条件； 改： update 表名 set 列名1=值1，列名2=值2... where 条件；二、复制数据1、通过一条查询语句创建一个新表(要求目标表不存在)```SQLcreate table manager as select empno,ename,sal, from emp where job= 'CLERK';```2、通过一条查询语句复制数据(要求目标表必须已建好)```SQLinsert into manager select empno,ename,sal from emp where job = 'CLERK';```三、序列1、创建序列如：创建从2000起始，增量为1 的序列abc：```SQLcreate sequence abc increment by 1 start with 2000maxvalue 99999 cycle nocache;```2、使用序列序列名.nextval: 代表下一个值序列名.currval: 代表当前值如：```SQLinsert into manager values(abc.nextval,'小王',2500);insert into manager values(abc.nextval,'小赵'，2800);```三、事务    两次连续成功的COMMIT或ROLLBACK之间的操作，称为一个事务。在一个事务内，数据的修改一起提交或撤销，如果发生故障或系统错误，整个事务也会自动撤销    数据库事务处理可分为隐式和显式两种。显式事务操作通过命令实现，隐式事务由系统自动完成提交或撤销(回退)工作，无需用户的干预。1、隐式提交的情况包括：    当用户正常退出SQL*Plus或执行CREATE、DROP、GRANT、REVOKE等命令时会发生事务的自动提交。2、显示事务:COMMIT\t        数据库事务提交，将变化写入数据库ROLLBACK\t数据库事务回退，撤销对数据的修改SAVEPOINT\t创建保存点，用于事务的阶段回退"},{"title":"Oracle笔记——子查询、集合运算","url":"/article/Oracle笔记——子查询-集合运算","content":"Oracle笔记——子查询、集合运算 - 子查询、集合运算一、子查询通过把一个查询的结果作为另一个查询的一部分,子查询一般出现在SELECT语句的WHERE子句中，Oracle也支持在FROM或HAVING子句中出现子查询。子查询比主查询先执行，结果作为主查询的条件，在书写上要用圆括号扩起来，并放在比较运算符的右侧。1、单行子查询如：查询比SCOTT工资高的雇员名字和工资。select ename,sal from emp where sal>(select sal from emp where empno=7788);2、多行子查询*如果子查询返回多行的结果，则我们称它为多行子查询。多行子查询要使用不同的比较运算符号，它们是IN、ANY和ALL。如“CLERK”的工资的雇员信息。select empno,ename,job,sal from emp where sal  'CLERK';如：\t查询工资比所有的“SALESMAN”都高的雇员的编号、名字和工资。select empno,ename,job from emp where job in (select job from emp where deptno = 10) and deptno = 20;3.多列子查询**如果子查询返回多列，则对应的比较条件中也应该出现多列，这种查询称为多列子查询。以下是多列子查询的训练实例。**如： 查询职务和部门与SCOTT相同的雇员的信息。select empno, ename,sal from emp where (job,deptno) = (select job,deptno from emp where empno = 7788);4．在FROM从句中使用子查询在FROM从句中也可以使用子查询，在原理上这与在WHERE条件中使用子查询类似。有的时候我们可能要求从雇员表中按照雇员出现的位置来检索雇员，很容易想到的是使用rownum虚列。比如我们要求显示雇员表中6～9位置上的雇员，可以用以下方法如：查询雇员表中排在第6～9位置上的雇员。select ename, sal, from (select rownum as num,ename,sal from emp where rownum=6;二、集合运算操作描述union并集，合并两个操作的结果，去掉重复的部分union all并集，合并两个操作的结果，保留重复的部分minus差集，从前面的操作结果中去掉与后面操作结果相同的部分intersect交集，取两个操作结果中相同的部分如：查询部门10和部门20的所有职务。select job from emp where deptno = 10 unionselect job from emp where deptno = 20;如：查询只在部门表中出现，但没有在雇员表中出现的部门编号。select deptno from deptminusselect deptno from emp;"},{"title":"Oracle笔记——多表连接（二）、组函数、分组查询","url":"/article/Oracle笔记——多表连接（二）-组函数-分组查询","content":"Oracle笔记——多表连接（二）、组函数、分组查询 - 多表连接（二）、组函数、分组查询一、不等连接拿一个表作为另一表的查询条件或范围如：显示雇员名称，工资和所属工资等级。select e.ename,e.sal,s.grade from emp e,salgrade s where e.sal between s.losal and s.hisal;二、自连接自连接就是一个表，同本身进行连接。对于自连接可以想像存在两个相同的表(表和表的副本)，可以通过不同的别名区别两个相同的表（其它就是内连接)如：显示雇员名称和雇员的经理名称select worker.ename||'的经理是'||manager.ename as 雇员经理 from emp worker,emp manager where worker.mgr=manager.empno;三、组函数**组函数只能应用于SELECT子句、HAVING子句或ORDER BY子句中。组函数也可以称为统计函数。组函数忽略列的空值。对组可以应用组函数。在组函数中可使用DISTINCT或ALL关键字。ALL表示对所有非NULL值(可重复)进行运算。DISTINCT 表示对每一个非NULL值，如果存在重复值，则组函数只运算一次。如果不指明上述关键字，默认为ALL。**函数说明AVG求平均值COUNT求计数值，返回非空行数，*表示返回所有行MAX求最大值MIN求最小值SUM求和SIDDEV求标准偏差，是根据差的平方根得到的VARIANCE求统计方差四、分组查询1、如：按职务统计工资总和。select deptno,job,sum(sal) from emp group by deptno,job;2、多列分组如：按部门和职务分组统计工资总和。:select deptno,job,sum(sal) from emp group by deptno,job;3、HAVINGHAVING从句过滤分组后的结果，它只能出现在GROUP BY从句之后，而WHERE从句要出现在GROUP BY从句之前。如：统计各部门的最高工资，排除最高工资小于3000的部门。select deptno,max(sal) from emp group by deptno having max(sal)>=3000;4、分组统计结果排序可以使用ORDER BY从句对统计的结果进行排序，ORDER BY从句要出现在语句的最后。如：按职务统计工资总和并排序。select job 职务, sum(sal) 工资总和 from emp group by job order by sum(sal);5、组函数的嵌套使用如：求各部门平均工资的最高值。select max(avg(sal)) from emp group by deptno;"},{"title":"Oracle笔记——相等连接","url":"/article/Oracle笔记——相等连接","content":"Oracle笔记——相等连接 - 一、相等连接1、三个步骤A、先列出要显示的列： select ename,job,comm,emp,deptno,dnameB、列出查询的表： from emp,deptC、列出多表相连条件（主外键）：where emp.deptno=dept.deptno注意：如果两个表有同名列，那么前面必须接表名 如： emp.deptno ,如果不是同名字段则表名可以省略2、inner join 的写法select enaem,job,sal,comm,emp.deptno,dname from emp inner join dept on emp.deptno = dept.deptno;3、三表或三表以上的写法select 字段1，字段2 , 字段3 ...from 表1，表2，表3...where 表1.外键 = 表2.主键  and 表1.外键 = 表3.主键 and ...注意：两个表有一个条件 ，三个表有两个条件 ，四个表有三个条件 以此类推二、外连接（不等连接）左外连接即在内连接的基础上，左边表中有但右边表中没有的记录也以null的形式显示出来，右外连接则反之###1、写法1(右外连接)select ename,d.deptno,dname from emp e,dept d where e.deptno(+) = d.deptno(左外连接)select ename,d.deptno,dname from emp e,dept d where d.deptno = e.deptno(+)    2、写法2select ename,d.deptno,dname from emp e right join dept d on e.deptno = d.deptno  "},{"title":"Oracle笔记——函数(二)","url":"/article/Oracle笔记——函数(二)","content":"Oracle笔记——函数(二) - 函数（二）一、日期型函数Oracle使用内部数字格式来保存时间和日期，包括世纪、年、月、日、小时、分、秒。缺省日期格式为 DD-MON-YY，如“08-05月-03”代表2003年5月8日。1、SYSDATE：返回系统日期和时间的虚列函数。如：返回系统的当前日期。SELECT sysdate FROM dual;2、对两个日期相减，得到相隔天数。通过加小时来增加天数，24小时为一天，如12小时可以写成12/24(或0.5)。如：例1 假定当前的系统日期是2003年2月6日，求再过1000天的日期。SELECT sysdate+1000 AS \"NEW DATE\" FROM dual;例2：两个日期相减select to_date('1-1月-2000') - to_date('1-8月-1999') from dual;3、其它日期函数函数功能实例结果months_between返回两个日期间的月份months_between (‘04-11月-05’,‘11-1月-01’)57.7741935add_months返回把月份数加到日期上的新日期add_months(‘06-2月-03’,1)，add_months(‘06-2月-03’,-1)06-3月-03，06-1月-03next_day返回指定日期后的星期对应的新日期next_day(‘06-2月-03’,‘星期一’)10-2月-03last_day返回指定日期所在的月的最后一天last_day(‘06-2月-03’)28-2月-03round按指定格式对日期进行四舍五入round(to_date(‘13-2月-03’),‘YEAR’)，round(to_date(‘13-2月-03’),‘MONTH’)，round(to_date(‘13-2月-03’),‘DAY’)01-1月-03，01-2月-03，16-2月-03(按周四舍五入)如：返回2003年2月的最后一天。SELECT last_day('08-2月-03') FROM dual;假定当前的系统日期是2003年2月6日，显示部门10雇员的雇佣天数。SELECT ename, round(sysdate-hiredate) DAYS FROM emp WHERE  deptno = 10;二、转换函数函数功能实例结果To_char转换成字符串类型To_char(1234.5, ‘$9999.9’)$1234.5To_date转换成日期类型To_date(‘1980-01-01’, ‘yyyy-mm-dd’)01-1月-80To_number转换成数值类型To_number(‘1234.5’)1234.51．自动类型转换SELECT '12.5'+11 FROM dual;    //结果为：23.5SELECT  ‘12.5’||11 FROM dual;    //结果为：’12.511’2．日期类型转换代码代表的格式例子AM、PM上午、下午08 AMD数字表示的星期(1～7)1,2,3,4,5,6,7DD数字表示月中的日期(1～31)1,2,3,…,31MM两位数的月份01,02,…,12Y、YY、YYY、YYYY年份的后几位3,03,003,2003RR解决Y2K问题的年度转换DY简写的星期名MON,TUE,FRI,…DAY全拼的星期名MONDAY,TUESDAY,…MON简写的月份名JAN,FEB,MAR,…MONTH全拼的月份名JANUARY,FEBRUARY,…HH、HH1212小时制的小时(1～12)1,2,3,…,12HH2424小时制的小时(0～23)0,1,2,…,23MI分(0～59)0,1,2,…,59SS秒(0～59)0,1,2,…,59,./-;:原样显示的标点符号’TEXT’引号中的文本原样显示TEXT如：1、日期型转字符型将日期转换成带时间和星期的字符串并显示。SELECT TO_CHAR(sysdate,'YYYY-MM-DD HH24:MI:SS AM DY') FROM dual;将日期显示转换成中文的年月日。SELECT TO_CHAR(sysdate,'YYYY\"年\"MM\"月\"DD\"日\"') FROM dual;2.字符型转日期型往emp表中插入一条记录insert into emp values(8888,'张三','CLERK',7369,to_date('1-1月-2000'),1000,10,10);insert into emp values(8889,'李四','CLERK',7369,to_date('2000-01-01','YYYY-MM-DD'),1000,10,10);三、其他常用函数函数功能实例结果nvl空值转换函数nvl(null, ‘空’)空decode实现分支功能decode(1,1, ‘男’, 2, ‘女’)男userenv返回环境信息userenv(‘LANGUAGE’)SIMPLIFIED CHINESE_CHINA.ZHS16GBKgreatest返回参数的最大值greatest(20,35,18,9)35leastleast返回参数的最小值least(20,35,18,9)91．空值的转换如果对空值NULL不能很好的处理，就会在查询中出现一些问题。在一个空值上进行算术运算的结果都是NULL。最典型的例子是，在查询雇员表时，将工资sal字段和津贴字段comm进行相加，如果津贴为空，则相加结果也为空，这样容易引起误解。使用nvl函数，可以转换NULL为实际值。该函数判断字段的内容，如果不为空，返回原值；为空，则返回给定的值。如下3个函数，分别用新内容代替字段的空值：nvl(comm, 0)：用0代替空的Comm值。nvl(hiredate, '01-1月-97')：用1997年1月1日代替空的雇佣日期。nvl(job, '无')：用“无”代替空的职务。使用nvl函数转换空值。SELECT\tename,nvl(job,'无'),nvl(hiredate,'01-1月-97'),nvl(comm,0) FROM\t emp;2．decode函数decode函数可以通过比较进行内容的转换，完成的功能相当于分支语句。在参数的最后位置上可以存在单独的参数，如果以上比较过程没有找到匹配值，则返回该参数的值，如果不存在该参数，则返回NULL。将职务转换成中文显示。SELECT\tename,decode(job, 'MANAGER', '经理', 'CLERK','职员', 'SALESMAN','推销员', 'ANALYST','系统分析员','未知') FROM emp;3．最大、最小值函数greatest返回参数列表中的最大值，least返回参数列表中的最小值。如果表达式中有NULL，则返回NULL。"},{"title":"Oracle笔记——条件查询、函数（一）","url":"/article/Oracle笔记——条件查询-函数（一）","content":"Oracle笔记——条件查询、函数（一） - 条件查询、函数（一）一、 条件查询1、模糊查询(between、in、like)A、between：在某某之间。如,显示工资在1000~2000之间的雇员select * from emp where sal beteween 1000 and 2000;B、in：在某某之间。如，显示职务为“SALMAN”，“CLEARK”和“MANAGER”的雇员信息select * from emp where job in ('SALMAN','CLERK','MANAGER');C、like：与通配符使用通配符：% 代表0个或任意个字符     —_ 代表1个字符如：显示姓名以“S”开头的雇员信息。select * from emp where ename like 'S%';显示姓名第二个字符为“A”的雇员信息select * from emp ename like '_A%';2、空值查询空：is null      非空： is not null如：查询奖金为空的雇员信息select * from emp where comm is null;二、函数1、数学函数函数功能实例结果abs求绝对值函数abs(-5)5sqrtsqrt(21.4142...power求幂函数power(2,3)8练习：使用求绝对值函数absselect abs(-5) from dual;使用求平方根函数sqrt。select sqrt(2) from dual;使用ceil函数。select ceil(2.35) from dual;使用floor函数。select floor(2.35) from dual;2、使用四舍五入函数round  格式：round(数字，保留的位数)例：select round(45.923,2), round(45.923,0), round(45.923,-1) from dual;3、字符型函数ascii返回与ASCII码相应的字符Ascii('A')65char返回与ASCII码相应的字符char(65)Alower将字符串转换成小写lower ('SQL Course')sql courseupper将字符串转换成upper('SQL Course')SQL COURSEinitcap将字符串转换成每个单词以大写开头initcap('SQL course')SQL Courseconcat连接两个字符串concat('SQL', ' Course')SQL Coursesubstr给出起始位置和长度，返回子字符串substr('String',1,3)Strlength求字符串的长度length('Wellcom')7trim在一个字符串中去除另一个字符串trim('S' FROM 'SSMITH')MITHreplace用一个字符串替换另一个字符串中的子字符串replace('ABC', 'B', 'D')ADC练习：如果不知道表的字段内容是大写还是小写，可以转换后比较。select empno, ename,deptno from emp where lower(ename)='blake';显示名称以“W”开头的雇员，并将名称转换成以大写开头。select empno,initcap(ename),job from emp wher substr(ename,1,1)='W';显示雇员名称中包含“S”的雇员名称及名称长度。select empno,ename,legth(ename) from emp where instr(ename,'S',1,1)>0;4、日期型函数Oracle使用内部数字格式来保存时间和日期，包括世纪、年、月、日、小时、分、秒。缺省日期格式为 DD-MON-YY，如“08-05月-03”代表2003年5月8日。SYSDATE是返回系统日期和时间的虚列函数。待续。。。"},{"title":"Oracle笔记——Oracle的基本查询","url":"/article/Oracle笔记——Oracle的基本查询","content":"Oracle笔记——Oracle的基本查询 - Oracle的基本查询一、基本查询select格式：    select 列名 from 表名 ；    where 查询条件    group by 分组列    having 分组后条件    order by 排序列 asc[desc]如：查询部门10的雇员​select * from emp where deptno=10;二、行号（rownum）每个表都有一个虚列ROWNUM，它用来显示结果中记录的行号。我们在查询中也可以显示这个列。如：显示emp表的行号select rownum,ename from emp;如：显示前三行select * from emp where rownum<=3;三、查询进行计算如：显示雇员工资上浮20%的结果​\tselect ename,sal,sal*(1+20%) from emp;如：显示每个员工的总工资（工资+奖金）​\tupdate emp set comm = o where comm is null;    //因为null的特殊性，它与任何值运算都等于null，所以先要把它更新为0，后面我们会学到一个函数来处理null值​\tselect ename,sal+comm from emp;四、使用别名如：在查询中使用列别名select ename as 名称，sal as 工资 from emp; //建议省略as另，在别名为关键字或有特殊符号时需要加双引号如：select ename as \"select\",sal*12+5000 as \"年度工资（加年终奖）\" from emp;五、连接运算符连接运算符是双竖线“||”。通过连接运算可以将两个字符串连接在一起。如：在查询中使用连接运算select ename||job as \"雇员和职务表\" from emp;*注意：‘5’||5结果为’55’    ‘5’+5结果为 10 *六、消除重复行（distinct）如果在显示结果中存在重复行，可以使用关键字distinct消除重复显示如：统计职务的数量select count(distinct job) from emp;七、排序1、升序（默认为升序asc,所以可以忽略）如：查询雇员姓名和工资，并按工资从小到大排序select ename,sal from emp order by sal asc;2、降序（desc不可忽略）如：查询雇员姓名和雇佣日期，并按雇佣日期排序，后雇佣的先显示select ename,hiredate from emp order by hiredate desc;3、多列排序可以按多列进行排序，先按第一列，然后按第二列、第三列…。如：查询雇员信息，先按部门从小到大排序，再按雇佣时间的先后排序select ename,deptno,hiredate from emp order by deptno hiredate;"},{"title":"JS的时间获取","url":"/article/JS的时间获取","content":"JS的时间获取 - JS获取系统时间JS自己拥有一个Date类来获取时间\tvar date = new Date();如果直接输出的话，会是这样：\t2017-11-03 13:59:25Wed Nov 22 2017 13:59:25 GMT+0800 (中国标准时间)可想而知，我们并不需要这么多的东西，所以Date类还给我们提供了一些方法来对时间进行格式化：\tvar year = date.getFullYear();      //获取年份 输出格式为“2017”\tvar month = date.getMonth();        //获取月份 输出格式为“10”（类定义0~11为1~12月，所以输出10位11月，实际使用注意在后面加1）\tvar day = date.getDate();         //获取日子（1~31）\tvar week = date.getDay();        //获取星期 （1~7）\tvar hour = date.getHours();        //获取小时数\tvar minute = date.getMinutes();     //获取分钟数\tvar second = date.getSeconds();      //获取秒钟格式化时间因为JS中不提供类似于JAVA中的SimpelDateFormat类，所以我们需要自己写一个格式化时间的方法\t\t  function Format(){\t\tvar newDate=new Date();\t\t\t\tvar year=newDate.getFullYear();\t\tvar month=(newDate.getMonth()+1)输出为：\t2017-11-22 14:15:34因为项目需要从前端获取时间存到数据库中，所以需要这种格式。后面再写一下时间字符串如何转化为Date的格式存进数据库。"},{"title":"Oracle笔记——DDL语句","url":"/article/Oracle笔记——DDL语句","content":"Oracle笔记——DDL语句 - 一、 创建表空间（在SqlServer中称为创建一个是数据库，而在Oracle中则称为创建一个表空间）格式： \tcreate tablespace 表空间名 datafile ‘文件路径’ size 文件大小如：cerate tablespace myspace datafile 'D:\\myspace.dbf' size10MB;删除表空间：drop tablespace myspace incluiding contents and datafile;二、创建用户格式： create user 用户名 identified by 密码 default tablespace 默认表空间如：create user user1 identified by user1 default tablespace system;删除用户：drop user user1 cascade;三、给用户授权方式一：授予角色connect     //登录resource    //普通权限，用于操作DBA         //管理员权限（慎用）如：grant connect to user1;grant connect,resource to user1;方式二：授予单个权限如：grant create table to user1;           //授予user1建表的权限grant drop table to user1;             //授予user1删表的权限方式三：将某个对象的权限授予用户如：grant select on scott.emp to user1;      //将scott用户的emp表的查询权限授予user1grant all on scott.emp to user1;       //将scott用户的emp表的所有权限授予user1 收回权限：格式： revoke 权限 from 用户如：revoke connect from user1;   //收回user1的connect权限revoke select on scott.emp from user1;    //收回user1对emp表的查询权限  "},{"title":"Oracle笔记——配置Oracle","url":"/article/Oracle笔记——配置Oracle","content":"Oracle笔记——配置Oracle - 配置Oracle1 首先打开Oracle服务2 配置监听器（这个是因为教室的电脑Oracle安装有问题，没有配置好监听器）      开始菜单中找到net configration assistant添加一个监听器3 用system用户登录sqlplus4 解锁scott用户 :（也是因为教室的Oracle安装问题导致scott账户未解锁）alter user scott account unlock;5 修改scott密码:alter user scott identified by tiger;6 使用scott登录sqlplus      scott是oracle自带的一个实例账户，它带有四个实例表,其中重要的就是emp员工表与dept部门表7 安装PL/SQL第三方工具因为Oracle没有自带的图形化界面管理器，所以我们需要安装PLSQL，它是oracle的一个第三方GUI工具介绍一下Oracle的命令连接数据库：connect scoott/tiger@orcl;         —用户名为scott，密码为tiger,数据库名为orcl显示当前用户：show user;也可使用查询语句：​\tselect USER from dual;              —dual是oracle的一个虚拟表显示表结构(以emp表为例)：describe emp;可简写为：​\tdesc emp;"},{"title":"Mysql高版本连接问题","url":"/article/Mysql高版本连接问题","content":"Mysql高版本连接问题 - Java使用mysql-jdbc连接MySQL出现如下警告：　　Establishing SSL connection without server’s identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn’t set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to ‘false’. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification.　　在mysql连接字符串url中加入ssl=true或者false即可，如下所示。url=jdbc:mysql://127.0.0.1/framework?characterEncoding=utf8&useSSL=true"}]